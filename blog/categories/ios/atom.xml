<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 王中周的技术博客]]></title>
  <link href="http://wangzz.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://wangzz.github.io/"/>
  <updated>2014-10-08T20:23:38+08:00</updated>
  <id>http://wangzz.github.io/</id>
  <author>
    <name><![CDATA[王中周]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iPhone屏幕知识点解析]]></title>
    <link href="http://wangzz.github.io/blog/2014/09/28/iphoneping-mu-zhi-shi-dian-jie-xi/"/>
    <updated>2014-09-28T14:34:37+08:00</updated>
    <id>http://wangzz.github.io/blog/2014/09/28/iphoneping-mu-zhi-shi-dian-jie-xi</id>
    <content type="html"><![CDATA[<p><img src="/images/article7/iphone5-6.jpg" alt="iphone5-6" /></p>

<h2>一、屏幕相关知识点</h2>

<h4>1、屏幕尺寸</h4>

<p>在显示器世界里，屏幕尺寸都是由屏幕对脚线长度表示的，单位是英寸。比如iPhone4的3.5寸屏就意味着屏幕对角线的长度是3.5英寸。</p>

<h4>2、分辨率</h4>

<p>分辨率是任何一款手机产品最重要的参数之一。显示屏是由一个个像素组成的，分辨率可以简单理解成屏幕像素的数目。比如iPhone4的屏幕分辨率为640×960，就表示屏幕的横向有640个像素点，纵向有960个像素点。</p>

<!-- more -->


<h4>3、PPI</h4>

<p>PPI（Pixels Per Inch）表示单位面积上的像素点数目。分辨率可以表示屏幕包含的像素数目，但要想描述屏幕的显示质量，还需要知道屏幕尺寸，最后算出单位面积上的像素点数目。显然PPI越高，屏幕显示效果越细腻。</p>

<p>PPI计算公式：</p>

<p><img src="/images/article7/PPI.jpg" alt="PPI" /></p>

<p>其中，X：长度像素数；Y：宽度像素数；Z：屏幕尺寸即对角线长度</p>

<h4>4、Points</h4>

<p>可以简单理解成我们使用<code>UIKit</code>或 <code>Core Animation</code>处理界面元素时所用到的逻辑坐标系统。Points是在iOS4以后引入的，出现的目的是提供一种与设备无关的一致的输出效果。</p>

<p>苹果考虑到以后有可能推出不同分辨率屏幕的手机，如果开发者在界面布局的时候操纵像素，就会导致每种不同分辨率的设备都要有一份适配代码。比如在分辨率为320×480的iPhone3GS上，要画一条长度1英寸的线条，假设需要50个像素，即线条的长度设成50像素；但是在分辨率为640×960的iPhone4上，50像素所能表示的实际长度只有iPhone3GS的一半，即0.5英寸。因此开发者必须使用两套适配代码：在iPhone3GS上将线条长度设成50像素，在iPhone4上设成100像素。这还仅仅是两款设备，如果算上后来的iPhone5/5C/5S和iPhone6/6+，每种分辨率都来一套适配代码，开发者岂不是得疯掉？？</p>

<p>现在苹果使用了一套逻辑坐标系统来解决多分辨率屏幕适配问题，将屏幕上的每一个点都用以屏幕左上角为原点，横向为X轴，纵向为Y轴的坐标来表示（PS：并不是所有的框架默认坐标系统都是这样，比如<code>APPKit</code>中的<code>NSView</code>；当然开发者也可以将<code>UIKit</code>和 <code>Core Animation</code>的坐标系统改成以屏幕左下角为原点，但原理都是一样的。）。以iPhone3GS/4为例，他们的坐标系统中X和Y的最大值都分别是320和480。</p>

<p>有了逻辑坐标系统，想在分辨率不同的iPhone3GS/4画一条长度均为1英寸的线条就变成了这样：将线的长度设成50Points（假设1英寸对应那么多个Points），<code>UIKit</code>在屏幕上绘图的时候会判断屏幕分辨率，如果是iPhone3GS的320×480分辨率屏幕，会自动使用50像素绘制；如果是iPhone4的640×960分辨率，会自动使用100像素绘制。</p>

<p>这种机制使得在4寸屏幕的iPhone5出来之前，iOS开发者在设备屏幕适配上的工作量几乎为零（当然，需要准备两套图片），对此Android同行们早就口水直下三千尺了。后来随着iPhone屏幕尺寸的变化，逻辑坐标系统的取值范围也发生了变化，这才让iOS开发者有点事情可做。</p>

<h4>5、渲染比例（Scale）</h4>

<p>像素点数目和逻辑坐标点数目的比值，就是渲染比例（Scale）。更直观的说法是一个逻辑坐标点，需要用几个像素点来渲染。</p>

<p>iPhone3GS的逻辑坐标系统是320×480，分辨率是320×480，即每个坐标点对应一个像素，即Scale为1；iPhone4的逻辑坐标系统是320×480，分辨率是640×960，每个坐标点对应两个像素点，即Scale为2。</p>

<p>因此，为了适配iPhone6+的屏幕，以后又得曾加一份@3x分辨率的图片了。</p>

<h4>6、宽高比</h4>

<p>屏幕宽度和高度的比例，也可以是分辨率的横向像素点数目和纵向像素点数目的比例，他们通常是一致的，一般用整数表示。</p>

<p>iPhone3GS/4/4S的宽高比2:3，iPhone5/5C/5S/6/6+的宽高比都是9:16。</p>

<p>当年iPhone5出来的时候，适配3.5寸屏幕的应用上下黑边的场景仍记忆犹新，用户体验很不好，虽然大部分应用都迅速的做了适配。还好苹果这次学聪明了，从4寸屏升级到iPhone6的4.7寸屏和iPhone6+的5.5寸屏，宽高比并没有变化。也就是说原来在iPhone5上运行的应用能够通过拉伸平滑过渡到iPhone6/6+上，可能会稍微有点模糊。不过比起3.5寸到4寸屏的升级来说已经好很多了。</p>

<h2>二、说明</h2>

<h4>1、历代iPhone屏幕参数</h4>

<p>下面的一张图介绍了从iPhone4到iPhone6+的几代iPhone跟屏幕相关的几个关键参数：</p>

<p><img src="/images/article7/iPhone_display.png" alt="iPhone_display" /></p>

<p>需要说明的是，iPhone6+的逻辑坐标是414×736，渲染比例是3倍，因此对应的屏幕分辨率是1242×2208。但iPhone6+的实际屏幕分辨率是1080×1920，这时系统会把整体的显示内容做一个从新采样缩放，downsampling比例为1/1.15。</p>

<h4>2、老工程中的坐标系统</h4>

<p>使用Xcode6之前版本的Xcode创建的工程，在iPhone6/6+上运行，得到的逻辑坐标都是和iPhone5/5C/5S屏幕相同的320*568。这样就做到从4寸到4.7寸和5.5寸屏幕的无缝升级，即使我们什么都不做，我们的老工程也能在iPhone6/6+上几乎完美的运行。当然因为等比例放大了，图片可能会有模糊或锯齿感。</p>

<p>要想让老工程的坐标系统恢复正常，可以通过为Target添加<code>LaunchImage</code>或者<code>Launch Screen File</code>来实现，如下图所示：</p>

<p><img src="/images/article7/LaunchFile.png" alt="LaunchFile" /></p>

<p><code>LaunchImage</code>的方式需要在<code>Images.xcassets</code>里，删除旧的<code>LaunchImage</code>组，然后新建<code>LaunchImage</code>组，添加对应高分辨率的图片。对此，这里有一篇更详细的图文介绍：<a href="http://matthewpalmer.net/blog/2014/09/10/iphone-6-plus-launch-image-adaptive-mode/">How to Add a Launch Image for the iPhone 6</a>。</p>

<p>其中<code>Launch Screen File</code>是Xcode6和iOS8新加的功能，它用一个xib文件来作为启动画面。App在旧版iOS启动时，该属性会被自动忽略，不会造成异常。</p>

<p>上面两种设置，只要启用任意一个即可让App进入高分辨率模式。鉴于现在不少App还需要兼容iOS5，而第一种方法在iOS5上可能有<a href="http://stackoverflow.com/questions/19220082/support-of-ios-5-0-icons-with-xcode-5">bug</a>，所以这里推荐用第二种方法。</p>

<h2>三、参考文档</h2>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingios/GraphicsDrawingOverview/GraphicsDrawingOverview.html">Drawing and Printing Guide for iOS</a></li>
<li><a href="http://baike.baidu.com/view/7687.htm">分辨率</a></li>
<li><a href="http://blog.ibireme.com/2014/09/16/adapted_to_iphone6/#rd?sukey=f3735aed1ca7f2658e86e2e18cb36d80fed889a7bdfd2d651a1aaef8f9941b691c71e4e8353e61cd57237e4cd0b3edc6#jtss-tsina">大屏iPhone的适配</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreAnimation系列之基础变换]]></title>
    <link href="http://wangzz.github.io/blog/2014/08/27/coreanimationxi-lie-zhi-ji-chu-bian-huan/"/>
    <updated>2014-08-27T12:21:50+08:00</updated>
    <id>http://wangzz.github.io/blog/2014/08/27/coreanimationxi-lie-zhi-ji-chu-bian-huan</id>
    <content type="html"><![CDATA[<p>从<a href="http://blog.csdn.net/wzzvictory">CSDN</a>时代开始，就有用一系列文章聊聊CoreAnimation的打算，这算是本系列中的第三篇了。一直以来都是哪天心情好的时候来一篇，真怀疑等把整个系列写完的时候CoreAnimation是不是都要被Apple换掉了。</p>

<p>本文打算介绍自己对基础变换的认识。</p>

<h2>一、基础变换与数学</h2>

<h4>1.两种坐标系</h4>

<p>不管是平面几何还是立体几何，笛卡尔坐标系都是我们学习和研究几何的最基础工具。的笛卡尔坐标系主要分两种：左手坐标系和右手坐标系。</p>

<p>对于三维坐标系，<a href="http://baike.baidu.com/view/2939423.htm">百度百科</a>上给出了右手坐标系的判断方法：在空间直角坐标系中，让右手拇指指向x轴的正方向，食指指向y轴的正方向，如果中指能指向z轴的正方向，则称这个坐标系为右手直角坐标系。同理左手直角三维坐标系。</p>

<!-- more -->


<p>下图直观的表示了上述判断方法（图片来自<a href="http://outofmemory.cn/wr/?u=http%3A%2F%2Fwonderffee.github.io%2Fblog%2F2013%2F10%2F17%2Fa-simple-method-to-determine-positive-rotation-in-in-three-dimensional-space%2F">这里</a>）：</p>

<p><img src="/images/article6/coordinate-system.jpg" alt="left-right hand coordinate" /></p>

<p>由此判断，从中学到大学的课堂上我们接触的立体几何都是右手系。</p>

<h4>2.基础变换的数学公式</h4>

<p>一个点在立体空间内的变换可以通过数学公式表示，前面讲那么多左手和右手坐标系相关的内容是因为<code>不同坐标系下计算公式不同</code>。</p>

<p>iOS中CoreAnimation的CALayer默认使用的是<code>左手坐标系</code>（使用哪种坐标系可以通过CALayer的<code>geometryFlipped</code>属性更改，该值默认为NO，设为YES时表示使用右手坐标系），因此本文后面所说的所有坐标系都是之左手坐标系。</p>

<p>变换对于动画来说应该是最基础最核心的内容了，CoreAnimation中基础变换包括平移（Translate）、缩放（Scale）、旋转（Rotate）三种。假如三维空间中有一个点(x0, y0, z0)，该点经过一定条件的基础变换，变换后的坐标为(x, y, z)，则针对平移、缩放、旋转三种基础变换，对应的坐标变换关系如下：</p>

<h6>2.1 平移</h6>

<p>平移对应的变化量为(δx, δy, δz)。</p>

<p><code>
x = x0 + δx;
y = y0 + δy;
z = z0 + δz;
</code></p>

<h6>2.2 缩放</h6>

<p>缩放对应的缩放倍数为(δx, δy, δz)。</p>

<p><code>
x = x0 * δx;
y = y0 * δy;
z = z0 * δz;
</code></p>

<h6>2.3 旋转</h6>

<p>旋转的方式有很多，比如简单点的绕X轴、Y轴、Z轴旋转，复杂点的还有绕任意三维向量旋转。为了简单起见，旋转以绕Z轴旋转了角度α（注意这里及后文所有涉及角度的地方都是弧度制）为例，对应的变化关系为：</p>

<p><code>
x = y0*sinα + x0*cosα;
y = y0*conα - x0*sinα;
z = z0;
</code></p>

<p>其它的大家感兴趣可以自己推倒下。</p>

<h2>二、变换矩阵</h2>

<p>在CoreAnimation中用CATransform3D来表示三维齐次坐标变换矩阵，在齐次坐标中n维空间的坐标需要用n+1个元素的坐标元组来表示（详情还请自行Google），因此CATransform3D定义如下：</p>

<p><code>
struct CATransform3D
{
  CGFloat m11, m12, m13, m14;
  CGFloat m21, m22, m23, m24;
  CGFloat m31, m32, m33, m34;
  CGFloat m41, m42, m43, m44;
};
</code>
为什么实现变换要有变换矩阵呢？</p>

<p>以上文中旋转的计算公式为例，可以使用如下矩阵运算表示：</p>

<p><img src="/images/article6/matrix1.png" alt="left-right hand coordinate" /></p>

<p>其中的矩阵：</p>

<p><img src="/images/article6/matrix2.png" alt="left-right hand coordinate" /></p>

<p>就被称为点(x0, y0, z0)绕Z轴旋转角度α的变换矩阵。</p>

<p>由于放射变换可以通过矩阵变换来实现，而且看起来更加直观，因此变换公式通常都用对应的变换矩阵表示。</p>

<p>在CoreAnimation中平移、缩放、旋转对应的变换矩阵为：</p>

<h4>1. 平移</h4>

<p><img src="/images/article6/matrix3.png" alt="left-right hand coordinate" /></p>

<p>其中δx、δy、δz表示三个坐标上对应的平移量。</p>

<h4>2. 缩放</h4>

<p><img src="/images/article6/matrix4.png" alt="left-right hand coordinate" /></p>

<p>其中δx、δy、δz表示三个坐标上对应的缩放倍数。</p>

<h4>3. 旋转</h4>

<p><img src="/images/article6/matrix5.png" alt="left-right hand coordinate" /></p>

<p>该矩阵为任意点(x, y, z)绕任意向量旋转旋转角度α的旋转向量。</p>

<h2>三、验证</h2>

<p>前面总结了CoreAnimation中三种基础变换对应的变换矩阵，这样以来我们就能自己对任意的矩阵做变换了。平移、缩放、旋转对应的变换矩阵计算方法如下：</p>

<h4>1. 平移</h4>

<p>```objective-c
&ndash; (CATransform3D)translateWithMatrix:(CATransform3D)t x:(CGFloat)x y:(CGFloat)y z:(CGFloat)z
{</p>

<pre><code>CATransform3D matrixTransform = CATransform3DIdentity;
matrixTransform.m41 = x;
matrixTransform.m42 = y;
matrixTransform.m43 = z;

return CATransform3DConcat(matrixTransform, t);
</code></pre>

<p>}
```</p>

<p>该方法根据平移变换矩阵的计算方式，得到平移参数(x, y, z)对应的变换矩阵，然后和原始矩阵相乘，得到最终的变换矩阵。</p>

<h4>2. 缩放</h4>

<p>```objective-c
&ndash; (CATransform3D)scaleWithMatrix:(CATransform3D)t x:(CGFloat)x y:(CGFloat)y z:(CGFloat)z
{</p>

<pre><code>CATransform3D matrixTransform = CATransform3DIdentity;
matrixTransform.m11 = x;
matrixTransform.m22 = y;
matrixTransform.m33 = z;

return CATransform3DConcat(matrixTransform, t);
</code></pre>

<p>}
```</p>

<p>该方法根据缩放变换矩阵的计算方式，得到缩放参数(x, y, z)对应的变换矩阵，然后和原始矩阵相乘，得到最终的变换矩阵。</p>

<h4>3. 旋转</h4>

<p>```objective-c
&ndash; (CATransform3D)rotateWithMatrix:(CATransform3D)t angle:(CGFloat)angle x:(CGFloat)x y:(CGFloat)y z:(CGFloat)z
{</p>

<pre><code>CGFloat unitValue = sqrtf(powf(x, 2)+powf(y, 2)+powf(z, 2));
CGFloat x0 = x/unitValue;
CGFloat y0 = y/unitValue;
CGFloat z0 = z/unitValue;

CATransform3D matrixTransform = CATransform3DIdentity;
matrixTransform.m11 = powf(x0, 2)*(1-cosf(angle))+cosf(angle);
matrixTransform.m12 = x0*y0*(1-cosf(angle))+z0*sinf(angle);
matrixTransform.m13 = x0*z0*(1-cosf(angle))-y0*sinf(angle);

matrixTransform.m21 = x0*y0*(1-cosf(angle))-z0*sinf(angle);
matrixTransform.m22 = powf(y0, 2)*(1-cosf(angle))+cosf(angle);
matrixTransform.m23 = y0*z0*(1-cosf(angle))+x0*sinf(angle);

matrixTransform.m31 = x0*z0*(1-cosf(angle))+y0*sinf(angle);
matrixTransform.m32 = y0*z0*(1-cosf(angle))-x0*sinf(angle);
matrixTransform.m33 = powf(z0, 2)*(1-cosf(angle))+cosf(angle);

return CATransform3DConcat(matrixTransform, t);
</code></pre>

<p>}
```</p>

<p>该方法根据旋转变换矩阵的计算方式，得到旋转参数(angle, x, y, z)对应的变换矩阵，然后和原始矩阵相乘，得到最终的变换矩阵。</p>

<h4>4. demo</h4>

<p>以旋转变换demo为例：</p>

<p>```objective-c
&ndash; (void)logTransform:(CATransform3D)t
{</p>

<pre><code>NSLog(@"***************************");
NSLog(@"%f,%f,%f,%f",t.m11,t.m12,t.m13,t.m14);
NSLog(@"%f,%f,%f,%f",t.m21,t.m22,t.m23,t.m24);
NSLog(@"%f,%f,%f,%f",t.m31,t.m32,t.m33,t.m34);
NSLog(@"%f,%f,%f,%f",t.m41,t.m42,t.m43,t.m44);
</code></pre>

<p>}</p>

<ul>
<li><p>(IBAction)onRotateButtonAction:(id)sender
{
  //Rotate</p>

<p>  //随意的原始矩阵
  CATransform3D matrixOrigin = CATransform3DMakeRotation(1, 4, 3, 6);</p>

<p>  CGFloat x = 2, y = 3, z = 4; //旋转向量（2,3,4）
  CGFloat angle = 30.0f * M_PI / 180.0f; //旋转角度30°，计算对应的弧度</p>

<p>  //通过系统函数计算变换矩阵
  CATransform3D matrixSystem = CATransform3DRotate(matrixOrigin, angle, x, y, z);
  systemLayer.transform = matrixSystem;
  [self logTransform:matrixSystem];</p>

<p>  //自定义方法计算3D旋转矩阵
  CATransform3D matrixCalculate = [self rotateWithMatrix:matrixOrigin angle:angle x:x y:y z:z];
  customLayer.transform = matrixCalculate;
  [self logTransform:matrixCalculate];
}
```</p></li>
</ul>


<p>demo使用随意生成的参数<code>matrixOrigin</code>模拟一个CALayer的初始<code>transform</code>属性值，然后使用同一组变换参数，分别通过系统函数和自定义方法对原始<code>transform</code>做变换，然后对比变换结果。最终的计算得到的变换矩阵可以通过log的方式打印出来，也可以在界面上做直观的展示。</p>

<p>平移和缩放变换矩阵的验证方式和旋转类似。</p>

<p>经过对比发现两种计算方式得到的最终变换矩阵是完全相同的，这进一步验证了CoreAnimation中变换矩阵的计算方式。</p>

<p>完整的<a href="https://github.com/wangzz/Demo/tree/master/CoreAnimationDemo">demo</a>放到了github上，欢迎大家下载。</p>

<h2>四、说明</h2>

<ul>
<li>变换矩阵可以组合</li>
</ul>


<p>可以同时对CALayer进行多种变换，比如同时缩放和旋转，直接通过矩阵相乘得到组合变换的变换矩阵。CoreAnimation提供了变换矩阵组合的方法：</p>

<p><code>objective-c
CATransform3D CATransform3DConcat (CATransform3D a, CATransform3D b)
</code>
需要注意的是，通常情况下矩阵乘法不支持交换律，因此两个矩阵a、b的顺序不能交换。</p>

<ul>
<li>最好不要手动修改变换矩阵的值</li>
</ul>


<p>CoreAnimation的3D变换对应的4维变换矩阵，单独修改其中的任何一个值都可能带来不可控的变换结果，因此不建议单独手动修改变换矩阵，而是通过基础变换或者基础变换组合的方式修改。</p>

<ul>
<li>理解有误的地方还望大家指出。</li>
</ul>


<h2>五、参考文档</h2>

<ul>
<li><a href="http://www.thinkandbuild.it/introduction-to-3d-drawing-in-core-animation-part-2/">INTRODUCTION TO 3D DRAWING IN CORE ANIMATION</a></li>
<li><a href="http://en.wikipedia.org/wiki/Rotation_matrix">Rotation matrix</a></li>
<li><a href="http://baike.baidu.com/view/2939423.htm">右手坐标系</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS屏幕旋转学习笔记]]></title>
    <link href="http://wangzz.github.io/blog/2014/08/08/ping-mu-xuan-zhuan-xue-xi-bi-ji/"/>
    <updated>2014-08-08T09:39:04+08:00</updated>
    <id>http://wangzz.github.io/blog/2014/08/08/ping-mu-xuan-zhuan-xue-xi-bi-ji</id>
    <content type="html"><![CDATA[<h2>一、两种orientation</h2>

<p>了解屏幕旋转首先需要区分两种orientation</p>

<h4>1、device orientation</h4>

<p>设备的物理方向</p>

<h4>2、interface orientation</h4>

<p>界面显示的方向</p>

<p>iOS提供了在设备旋转时，界面显示发生相应适配的能力，已达到方便用户使用并提供最佳显示效果的目的。开发者需要指定应用支持的显示方向，并对界面显示做出对应的适配。由于界面适配的工作量相当大，目前国内的应用大都只支持默认的竖屏方向，</p>

<!-- more -->


<h2>二、相关枚举定义</h2>

<h4>1、iOS5和之前版本（后文均简称iOS5）：</h4>

<p>```
typedef NS_ENUM(NSInteger, UIInterfaceOrientation) {</p>

<pre><code>UIInterfaceOrientationPortrait           = UIDeviceOrientationPortrait,
UIInterfaceOrientationPortraitUpsideDown = UIDeviceOrientationPortraitUpsideDown,
UIInterfaceOrientationLandscapeLeft      = UIDeviceOrientationLandscapeRight,
UIInterfaceOrientationLandscapeRight     = UIDeviceOrientationLandscapeLeft
</code></pre>

<p>};
```</p>

<h4>2、iOS6和之后版本（后文均简称iOS6）又新增了：</h4>

<p>```
typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) {</p>

<pre><code>UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait),
UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft),
UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight),
UIInterfaceOrientationMaskPortraitUpsideDown = (1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown),
UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),
UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown),
UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),
</code></pre>

<p>};
```</p>

<p>iOS6使用<code>NS_OPTIONS</code>的方式重新定义了UIInterfaceOrientationMaskPortrait、UIInterfaceOrientationMaskLandscapeLeft、UIInterfaceOrientationMaskLandscapeRight、UIInterfaceOrientationMaskPortraitUpsideDown几种基础枚举，这就意味着能以组合的方式更加方便的使用这些枚举值。</p>

<h2>三、相关方法</h2>

<h4>1、iOS5中控制屏幕旋转的方法：</h4>

<p><code>
// Applications should use supportedInterfaceOrientations and/or shouldAutorotate..
- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation NS_DEPRECATED_IOS(2_0, 6_0);
</code>
如果打算支持toInterfaceOrientation对应的方向就返回YES，否则返回NO。</p>

<h4>2、iOS6中控制屏幕旋转相关方法：</h4>

<p>```
// New Autorotation support.
&ndash; (BOOL)shouldAutorotate NS_AVAILABLE_IOS(6_0);
&ndash; (NSUInteger)supportedInterfaceOrientations NS_AVAILABLE_IOS(6_0);
// Returns interface orientation masks.
&ndash; (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation NS_AVAILABLE_IOS(6_0);</p>

<p>```</p>

<p>第一个方法决定是否支持多方向旋转屏，如果返回NO则后面的两个方法都不会再被调用，而且只会支持默认的UIInterfaceOrientationMaskPortrait方向；</p>

<p>第二个方法直接返回支持的旋转方向，该方法在iPad上的默认返回值是<code>UIInterfaceOrientationMaskAll</code>，iPhone上的默认返回值是<code>UIInterfaceOrientationMaskAllButUpsideDown</code>，详情见<a href="https://developer.apple.com/library/ios/qa/qa1688/_index.html">官方Q&amp;A文档</a>；</p>

<p>第三个方法返回最优先显示的屏幕方向，比如同时支持Portrait和Landscape方向，但想优先显示Landscape方向，那软件启动的时候就会先显示Landscape，在手机切换旋转方向的时候仍然可以在Portrait和Landscape之间切换；</p>

<h4>3、attemptRotationToDeviceOrientation方法</h4>

<p>从iOS5开始有了这个新方法：</p>

<p><code>
// call this method when your return value from shouldAutorotateToInterfaceOrientation: changes
// if the current interface orientation does not match the current device orientation, a rotation may occur provided all relevant view controllers now return YES from shouldAutorotateToInterfaceOrientation:
+ (void)attemptRotationToDeviceOrientation NS_AVAILABLE_IOS(5_0);
</code></p>

<p>该方法的使用场景是interface orientation和device orientation不一致，但希望通过重新指定interface orientation的值，立即实现二者一致；如果这时只是更改了支持的interface orientation的值，没有调用attemptRotationToDeviceOrientation，那么下次device orientation变化的时候才会实现二者一致，关键点在于能不能立即实现。</p>

<p>举个例子：</p>

<p>假设当前的interface orientation只支持Portrait，如果device orientation变成Landscape，那么interface orientation仍然显示Portrait；</p>

<p>如果这时我们希望interface orientation也变成和device orientation一致的Landscape，以iOS6为例，需要先将supportedInterfaceOrientations的返回值改成Landscape，然后调用attemptRotationToDeviceOrientation方法，系统会重新询问支持的interface orientation，已达到立即更改当前interface orientation的目的。</p>

<h2>四、如何决定interface orientation</h2>

<h4>1、全局控制</h4>

<p>Info.plist文件中，有一个<code>Supported interface orientations</code>，可以配置整个应用的屏幕方向，此处为全局控制。</p>

<h4>2、UIWindow</h4>

<p>iOS6的UIApplicationDelegate提供了下述方法，能够指定 UIWindow 中的界面的屏幕方向：</p>

<p><code>
- (NSUInteger)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window  NS_AVAILABLE_IOS(6_0);
</code>
该方法默认值为Info.plist中配置的<code>Supported interface orientations</code>项的值。</p>

<p>iOS中通常只有一个window，所以此处的控制也可以视为全局控制。</p>

<h4>3、controller</h4>

<p>只有以下两种情况：</p>

<ul>
<li>当前controller是window的rootViewController</li>
<li>当前controller是modal模式的</li>
</ul>


<p>时，orientations相关方法才会起作用（才会被调用），当前controller及其所有的childViewController都在此作用范围内。</p>

<h4>4、最终支持的屏幕方向</h4>

<p>前面所述的3种控制规则的交集就是一个controller的最终支持的方向；</p>

<p>如果最终的交集为空，在iOS6以后会抛出<code>UIApplicationInvalidInterfaceOrientationException</code>崩溃异常。</p>

<h2>四、强制屏幕旋转</h2>

<p>如果interface和device方向不一样，想强制将interface旋转成device的方向，可以通过attemptRotationToDeviceOrientation实现，但是如果想将interface强制旋转成任一指定方向，该方式就无能为力了。</p>

<p>不过聪明的开发者们总能想到解决方式：</p>

<h4>1、私有方法</h4>

<p><code>
[[UIDevice currentDevice] setOrientation:UIInterfaceOrientationPortrait];
</code>
但是现在苹果已经将该方法私有化了，越狱开发的同学可以试试。</p>

<h4>2、旋转view的transform</h4>

<p>也可以通过旋转view的transform属性达到强制旋转屏幕方向的目的，但个人感觉这不是靠谱的思路，可能会带来某些诡异的问题。</p>

<h4>3、主动触发orientation机制</h4>

<p>要是能主动触发系统的orientation机制，调用orientation相关方法，使新设置的orientation值起作用就好了。这样只要提前设置好想要支持的orientation，然后主动触发orientation机制，便能实现将interface orientation旋转至任意方向的目的。</p>

<p>万能的<a href="http://stackoverflow.com/a/14445888/2293677">stackoverflow</a>上提供了一种主动触发的方式：</p>

<p>在iOS4和iOS6以后：</p>

<p><code>
UIViewController *vc = [[UIViewController alloc]init];
[self presentModalViewController:vc animated:NO];
[self dismissModalViewControllerAnimated:NO];
[vc release];
</code></p>

<p>iOS5中：</p>

<p><code>
UIWindow *window = [[UIApplication sharedApplication] keyWindow];
UIView *view = [window.subviews objectAtIndex:0];
[view removeFromSuperview];
[window addSubview:view];
</code>
这种方式会触发UIKit重新调用controller的orientation相关方法，以达到在device方向不变的情况下改变interface方向的目的。</p>

<p>虽然不优雅，但却能解决问题，凑合吧。。</p>

<p>PS：</p>

<p>话说iOS8中的屏幕旋转相关方法又变化了，表示适配起来很蛋疼。。。</p>

<h2>五、参考文档</h2>

<ul>
<li><a href="https://developer.apple.com/library/ios/qa/qa1688/_index.html">Why won&rsquo;t my UIViewController rotate with the device?</a>；</li>
<li><a href="http://stackoverflow.com/a/14445888/2293677">How to force a UIViewController to Portait orientation in iOS 6</a></li>
<li><a href="http://www.cnblogs.com/jhzhu/p/3480885.html">IOS Orientation, 想怎么转就怎么转</a></li>
<li><a href="http://zhenby.com/blog/2013/08/20/talk-ios-orientation/">iOS 屏幕方向那点事儿</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS进程间通信之CFMessagePort]]></title>
    <link href="http://wangzz.github.io/blog/2014/06/04/iosjin-cheng-jian-tong-xin-zhi-cfmessageport/"/>
    <updated>2014-06-04T18:31:51+08:00</updated>
    <id>http://wangzz.github.io/blog/2014/06/04/iosjin-cheng-jian-tong-xin-zhi-cfmessageport</id>
    <content type="html"><![CDATA[<p>iOS系统是出了名的封闭，每个应用的活动范围被严格地限制在各自的沙盒中。尽管如此，iOS还是提供了若干进程间通信机制，CFMessagePort就是其中之一。</p>

<p>从类名可以看出，CFMessagePort属于<code>Core Foundation</code>层的东西，其实现部分是开源的，代码在可以在苹果的<a href="http://opensource.apple.com/source/CF/CF-855.14/CFMessagePort.c">开源代码库</a>中找到。</p>

<h2>使用方式</h2>

<h4>1、消息接收者</h4>

<p>CFMessagePort端口消息的接收者需要实现以下功能：</p>

<h6>1.1 注册监听</h6>

<p>消息接收者需要通过以下方式注册消息监听：</p>

<p>```objective-c
&ndash;(void)startListenning
{</p>

<pre><code>if (0 != mMsgPortListenner &amp;&amp; CFMessagePortIsValid(mMsgPortListenner))
{
    CFMessagePortInvalidate(mMsgPortListenner);
}
mMsgPortListenner = CFMessagePortCreateLocal(kCFAllocatorDefault,CFSTR(LOCAL_MACH_PORT_NAME),onRecvMessageCallBack, NULL, NULL);
CFRunLoopSourceRef source = CFMessagePortCreateRunLoopSource(kCFAllocatorDefault, mMsgPortListenner, 0);
CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopCommonModes);
NSLog(@"start listenning");
</code></pre>

<p>}
```</p>

<p> <!-- more --></p>

<p>其中<code>LOCAL_MACH_PORT_NAME</code>的定义为：</p>

<p>```objective-c</p>

<h1>define LOCAL_MACH_PORT_NAME    &ldquo;com.wangzz.demo&rdquo;</h1>

<p>```</p>

<p>经过查看源码发现，CFMessagePort实际上是通过mach port实现的。Mach port是iOS系统提供的基于端口的输入源，可用于线程或进程间通讯。而Runloop支持的输入源类型中就包括基于端口的输入源，因此可以使用Runloop做为CFMessagePort端口源事件的监听者。</p>

<p>上述代码有几点需要说明：</p>

<ul>
<li><p>通过CFMessagePortCreateLocal可以创建一个本地CFMessagePortRef对象</p></li>
<li><p>CFMessagePort对象是靠一个字符串来唯一标识的，这一点非常重要，在这里字符串是由宏<code>LOCAL_MACH_PORT_NAME</code>定义的；</p></li>
<li><p>创建CFMessagePort对象的同时设置了端口源事件的回调函数onRecvMessageCallBack，用于处理端口源事件；</p></li>
<li><p>将创建的对象作为输入源添加到Runloop中，从而实现对端口源事件的监听，当Runloop收到对应的端口源事件时，会调用上一步中指定的回调芳芳；</p></li>
</ul>


<h6>1.2 实现回调方法</h6>

<p>回调函数为CFMessagePortCallBack类型，其定义部分为：
<code>objective-c
typedef CFDataRef (*CFMessagePortCallBack) (
   CFMessagePortRef local,
   SInt32 msgid,
   CFDataRef data,
   void *info
);
</code>
各个参数的含义为：</p>

<ul>
<li><p>CFMessagePortRef local</p>

<p>  当前接收消息的CFMessagePortRef对象。</p></li>
<li><p>SInt32 msgid</p>

<p>  这个字段非常有用，用于标识消息。如果通信双方进程约定号每个msgid对应的数据结构，即可实现较为复杂的通信。</p></li>
<li><p>CFDataRef data</p>

<p>  通信的真正数据部分。</p></li>
<li><p>void *info</p>

<p>  为使用CFMessagePortCreateLocal方法创建port端口时指定的CFMessagePortContext对象的info字段，通常为空。</p></li>
</ul>


<p>该回调方法可以返回一个CFDataRef类型的数据给port消息的发送者，以实现有效的双方通信，这一点也非常重要。</p>

<p>我的回调函数onRecvMessageCallBack的实现：</p>

<p>```objective-c
CFDataRef onRecvMessageCallBack(CFMessagePortRef local,SInt32 msgid,CFDataRef cfData, void*info)
{</p>

<pre><code>NSLog(@"onRecvMessageCallBack is called");
NSString *strData = nil;
if (cfData)
{
    const UInt8  * recvedMsg = CFDataGetBytePtr(cfData);
    strData = [NSString stringWithCString:(char *)recvedMsg encoding:NSUTF8StringEncoding];
    /**

     实现数据解析操作

     **/

    NSLog(@"receive message:%@",strData);
}

//为了测试，生成返回数据
NSString *returnString = [NSString stringWithFormat:@"i have receive:%@",strData];
const char* cStr = [returnString UTF8String];
NSUInteger ulen = [returnString lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
CFDataRef sgReturn = CFDataCreate(NULL, (UInt8 *)cStr, ulen);

return sgReturn;
</code></pre>

<p>}
```</p>

<p>该方法实现的较为简单，解析约定的数据（测试代码中约定传送的是string）,为了测试，同时生成一个CFDataRef数据返回给port消息的发送者。</p>

<h6>1.3 取消端口监听</h6>

<p>可以通过如下方式取消对port端口的监听：</p>

<p>```objective-c
&ndash; (void)endLisenning
{</p>

<pre><code>CFMessagePortInvalidate(mMsgPortListenner);
CFRelease(mMsgPortListenner);
</code></pre>

<p>}
```
CFMessagePortInvalidate会停止port消息的发送和接收操作，而只有调用了CFRelease，CFMessagePortRef对象才真正的被释放掉。</p>

<h4>2、消息发送者</h4>

<p>发送部分代码如下：</p>

<p>```objective-c
&ndash;(NSString *)sendMessageToDameonWith:(id)msgInfo msgID:(NSInteger)msgid
{</p>

<pre><code>// 生成Remote port
CFMessagePortRef bRemote = CFMessagePortCreateRemote(kCFAllocatorDefault, CFSTR(MACH_PORT_REMOTE));
if (nil == bRemote) {
    NSLog(@"bRemote create failed");
    return nil;
}

// 构建发送数据（string）
NSString    *msg = [NSString stringWithFormat:@"%@",msgInfo];
NSLog(@"send msg is :%@",msg);
const char *message = [msg UTF8String];
CFDataRef data,recvData = nil;
data = CFDataCreate(NULL, (UInt8 *)message, strlen(message));

// 执行发送操作
CFMessagePortSendRequest(bRemote, msgid, data, 0, 100 , kCFRunLoopDefaultMode, &amp;recvData);
if (nil == recvData) {
    NSLog(@"recvData date is nil.");
    CFRelease(data);
    CFMessagePortInvalidate(bRemote);
    CFRelease(bRemote);
    return nil;
}

// 解析返回数据
const UInt8  * recvedMsg = CFDataGetBytePtr(recvData);
if (nil == recvedMsg) {
    NSLog(@"receive date err.");
    CFRelease(data);
    CFMessagePortInvalidate(bRemote);
    CFRelease(bRemote);
    return nil;
}

NSString    *strMsg = [NSString stringWithCString:(char *)recvedMsg encoding:NSUTF8StringEncoding];
NSLog(@"%@",strMsg);

CFRelease(data);
CFMessagePortInvalidate(bRemote);
CFRelease(bRemote);
CFRelease(recvData);

return strMsg;
</code></pre>

<p>}</p>

<p>```</p>

<p>其中<code>MACH_PORT_REMOTE</code>的定义为：</p>

<p>```objective-c</p>

<h1>define MACH_PORT_REMOTE    &ldquo;com.wangzz.demo&rdquo;</h1>

<p>```</p>

<p>发送消息时要相对简单，首先通过CFMessagePortCreateRemote生成一个Remote的CFMessagePortRef，这里需要注意的是CFMessagePortCreateRemote时传入的字符串唯一标识<code>MACH_PORT_REMOTE</code>必须和消息接收者创建local的CFMessagePortRef时使用的字符串唯一标识是同一个！</p>

<p>通过查看源码发现，CFMessagePortCreateRemote会根据<code>MACH_PORT_REMOTE</code>定义的字符串为唯一标识获取消息接收者通过CFMessagePortCreateLocal使用相同字符串创建的底层mach port端口，从而实现向消息接收者发送信息。</p>

<p>如果消息接收者还没有创建或者通过CFMessagePortCreateLocal创建local端口失败时，想要通过CFMessagePortCreateRemote去创建remote端口肯定是失败的。</p>

<h2>说明</h2>

<ul>
<li>很遗憾的是，在iOS7及以后系统中，CFMessagePort的通信机制不再可用。</li>
</ul>


<p>在使用CFMessagePortCreateLocal/CFMessagePortCreateRemote创建CFMessagePortRef对象时会失败，官方文档中是这么说的：</p>

<p><code>
This method is not available on iOS 7 and later—it will return NULL and log a sandbox violation in syslog. See Concurrency Programming Guide for possible replacement technologies.
</code></p>

<ul>
<li><p>CFMessagePort只能用于本地进程通信。</p></li>
<li><p>CFMessagePort是基于mach port端口的通信方式，不但可以用于进程通信，也可以用于线程间通信，只是线程间通信有了GCD和Cocoa提供的原生方法，已经能很方便的实现了，没必要再使用CFMessagePort。</p></li>
<li><p>进程通信使用场景</p></li>
</ul>


<p>iOS系统多任务机制，使得进程间通信基本都只能用于越狱开发。常用的场景是前端有一个UI程序用于界面展示，后端有一个daemo精灵程序用于任务处理。</p>

<h2>demo工程</h2>

<p>特地做了了个demo工程，以便更好地演示CFMessagePort的使用，可以到<a href="http://download.csdn.net/detail/wzzvictory_tjsd/7446745">CSDN下载</a>。</p>

<p>为了模拟进程间通信场景，我将消息接收进程CFMessagePortReceive做成了能够后台播放音乐的程序，以便其切到后台后能继续存活。</p>

<p>由于CFMessagePort不再支持iOS7及以后系统，本demo实在iOS6系统上测试的。</p>

<p>demo使用方式：</p>

<ul>
<li><p>CFMessagePortReceive启动后，点击Start Listenning创建CFMessagePort接口并开始监听port消息，然后将CFMessagePortReceive切到后台；</p></li>
<li><p>启动CFMessagePortSend程序，在输入框中写入内容，点击发送按钮即可和CFMessagePortReceive通信。</p></li>
<li><p>MessagePort通信过程中会有日志输出，可以使用以下方式查看日志：</p>

<p>  1.真机</p>

<p>  选择：Xcode->Window->Organizer->Devices，然后选中窗口左侧当前设备的Console窗口查看。</p>

<p>  2.模拟器</p>

<p>  选择：模拟器->调试->打开系统日志，或者直接使用快捷键<code>⌘/</code>直接打开系统控制台查看日志。</p></li>
</ul>


<h2>参考文档</h2>

<ul>
<li><p><a href="http://opensource.apple.com/source/CF/CF-855.14/">CF-855.14</a></p></li>
<li><p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">Threading Programming Guide</a></p></li>
<li><p><a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFMessagePortRef/Reference/reference.html#//apple_ref/doc/uid/20001437-CH203-DontLinkElementID_8">CFMessagePort Reference</a></p></li>
</ul>

]]></content>
  </entry>
  
</feed>
