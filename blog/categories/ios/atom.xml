<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 王中周的技术博客]]></title>
  <link href="http://wangzz.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://wangzz.github.io/"/>
  <updated>2015-06-16T20:03:42+08:00</updated>
  <id>http://wangzz.github.io/</id>
  <author>
    <name><![CDATA[王中周]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[离屏渲染学习笔记]]></title>
    <link href="http://wangzz.github.io/blog/2015/05/06/chi-ping-xuan-ran-xue-xi-bi-ji/"/>
    <updated>2015-05-06T17:17:55+08:00</updated>
    <id>http://wangzz.github.io/blog/2015/05/06/chi-ping-xuan-ran-xue-xi-bi-ji</id>
    <content type="html"><![CDATA[<h2>一、概念理解</h2>

<p>OpenGL中，GPU屏幕渲染有以下两种方式：</p>

<ul>
<li>On-Screen Rendering</li>
</ul>


<p>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p>

<ul>
<li>Off-Screen Rendering</li>
</ul>


<p>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p>

<!-- more -->


<h2>二、离屏渲染的是是非非</h2>

<p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：</p>

<ul>
<li>创建新缓冲区</li>
</ul>


<p>要想进行离屏渲染，首先要创建一个新的缓冲区。</p>

<ul>
<li>上下文切换</li>
</ul>


<p>离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</p>

<h2>三、离屏渲染触发方式</h2>

<p>设置了以下属性时，都会触发离屏绘制：</p>

<ul>
<li>shouldRasterize（光栅化）</li>
<li>masks（遮罩）</li>
<li>shadows（阴影）</li>
<li>edge antialiasing（抗锯齿）</li>
<li>group opacity（不透明）</li>
</ul>


<p>需要注意的是，如果shouldRasterize被设置成YES，在触发离屏绘制的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。这将在很大程度上提升渲染性能。</p>

<p>而其它属性如果是开启的，就不会有缓存，离屏绘制会在每一帧都发生。</p>

<h2>四、另一种特殊的“离屏渲染”</h2>

<p>按照之前的说法，如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式：<code>CPU渲染</code>。</p>

<p>如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内<code>同步地</code>完成，渲染得到的bitmap最后再交由GPU用于显示。</p>

<h2>五、Instruments</h2>

<p>Instruments的Core Animation工具中有几个和离屏渲染相关的检查选项：</p>

<ul>
<li>Color Offscreen-Rendered Yellow</li>
</ul>


<p>开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。</p>

<ul>
<li>Color Hits Green and Misses Red</li>
</ul>


<p>如果shouldRasterize被设置成YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。</p>

<h2>六、如何抉择</h2>

<p>现在摆在我们面前得有三个选择：当前屏幕渲染、离屏渲染、CPU渲染，该用哪个呢？这需要根据具体的使用场景来决定。</p>

<ul>
<li>尽量使用当前屏幕渲染</li>
</ul>


<p>鉴于离屏渲染、CPU渲染可能带来的性能问题，一般情况下，我们要尽量使用当前屏幕渲染。</p>

<ul>
<li>离屏渲染 VS CPU渲染</li>
</ul>


<p>由于GPU的浮点运算能力比CPU强，CPU渲染的效率可能不如离屏渲染；但如果仅仅是实现一个简单的效果，直接使用CPU渲染的效率又可能比离屏渲染好，毕竟离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作。</p>

<p>总之，具体的选择应该由性能测试结果来决定。</p>

<h2>七、写在最后</h2>

<p>在赵岩同学的点拨下才理解了离屏渲染的概念，在此表示感谢！</p>

<p>如理解有误还请大家指出。</p>

<h2>参考文档</h2>

<ul>
<li><p><a href="http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html">Getting Pixels onto the Screen</a> (中文翻译版：<a href="http://objccn.io/issue-3-1/">绘制像素到屏幕上</a>)</p></li>
<li><p><a href="https://robots.thoughtbot.com/designing-for-ios-graphics-performance">Designing for iOS: Graphics &amp; Performance</a>  (中文翻译版：<a href="http://www.taofengping.com/2013/05/18/designing-for-ios-graphics-performance/#.VUinciGqpBc">iOS图形处理和性能</a>)</p></li>
<li><p><a href="https://lobste.rs/s/ckm4uw/a_performance-minded_take_on_ios_design">a performance minded take on ios design</a>  (中文翻译版：<a href="http://www.taofengping.com/2013/05/18/ios_offscreen_analysis/#.VUinPyGqpBd">iOS离屏绘制的性能和机制分析</a>)</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Code Signing 学习笔记]]></title>
    <link href="http://wangzz.github.io/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/"/>
    <updated>2014-10-16T19:09:38+08:00</updated>
    <id>http://wangzz.github.io/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p>最近看了objc.io上第17期中的文章<a href="http://www.objc.io/issue-17/inside-code-signing.html">《Inside Code Signing》</a>对应的中文翻译版<a href="http://objccn.io/issue-17-2/">《代码签名探析》</a>，收益颇深，对iOS代码签名机制有了进一步的认识。想了解详细内容建议大家还是去看原文好了。</p>

<p>下面是对此文章的理解再结合自己之前对该部分的认识写出的学习笔记。本文的前提是已经对非对称加密有了一定的了解。</p>

<h2>一、数字签名（digital signature）</h2>

<p>对指定信息使用哈希算法，得到一个固定长度的信息摘要，然后再使用<code>私钥</code>（注意必须是私钥）对该摘要加密，就得到了数字签名。所谓的代码签名就是这个意思。</p>

<!-- more -->


<h2>二、数字证书（digital certificate）</h2>

<h4>证书生成</h4>

<p>开发者在申请iOS开发证书时，需要通过keychain生成一个CSR文件（Certificate Signing Request），提交给苹果的<code>Apple Worldwide Developer Relations Certification Authority</code>(WWDR)证书认证中心进行签名，最后从苹果官网下载并安装使用。这个过程中还会产生一个私钥，证书和私钥在keychain中得位置如图：</p>

<p><img src="http://img.objccn.io/issue-17/iphone-developer-keychain.png" alt="cer_private_key" /></p>

<h4>证书组成</h4>

<p>经过<code>WWDR</code>数字签名后的数字证书长这个样子：</p>

<p><img src="http://img.blog.csdn.net/20130603170838968" alt="digital certificate" /></p>

<p>其中包含两大部分：</p>

<ul>
<li>证书本身</li>
</ul>


<p>包含用户的公钥、用户个人信息、证书颁发机构信息、证书有效期等信息。</p>

<ul>
<li>证书签名</li>
</ul>


<p><code>WWDR</code>将上述证书本身内容的使用哈希算法得到一个固定长度的信息摘要，然后使用自己的<code>私钥</code>对该信息摘要加密生成数字签名，整个过程如图所示：</p>

<p><img src="http://img.blog.csdn.net/20130603170752859" alt="digital signature" /></p>

<h4>证书使用</h4>

<p>iOS系统原本就持有<code>WWDR</code>的公钥，系统首先会对证书内容通过指定的哈希算法计算得到一个信息摘要；然后使用<code>WWDR</code>的公钥对证书中包含的数字签名解密，从而得到经过<code>WWDR</code>的私钥加密过的信息摘要；最后对比两个信息摘要，如果内容相同就说明该证书可信。整个过程如图所示：</p>

<p><img src="http://img.blog.csdn.net/20130603170924312" alt="verify" /></p>

<p>在验证了证书是可信的以后，iOS系统就可以获取到证书中包含的开发者的公钥，并使用该公钥来判断代码签名的可用性了。</p>

<h4>证书存在的意义</h4>

<p>通过证书使用过程可以看出，证书本身只是一个中间媒介，iOS系统对证书并不关心，它其实只想要证书中包含的开发者的公钥！！</p>

<p>但是开发者怎么才能证明公钥是自己的呢？iOS安全系统怎么才能相信这个公钥就是这个开发者的呢？</p>

<p>不管是哪一个开发者对iOS的安全系统说，这个公钥就是我的，系统是都不相信的，即系统对开发者有着百分之百的不信任感。但是iOS安全系统对自家的<code>WWDR</code>是可信任的，苹果将<code>WWDR</code>的公钥内置在了iOS系统中。有了证书，iOS安全系统只需要通过<code>WWDR</code>的公钥就可以获取到任何一个开发者的可信任的公钥了，这就是证书存在的意义！！</p>

<h2>三、公钥（public key）</h2>

<p>公钥被包含在数字证书里，数字证书又被包含在<code>描述文件</code>(Provisioning File)中，<code>描述文件</code>在应用被安装的时候会被拷贝到iOS设备中。</p>

<p>iOS安全系统通过证书就能够确定开发者身份，就能够通过从证书中获取到的公钥来验证开发者用该公钥对应的私钥签名后的代码、资源文件等有没有被更改破坏，最终确定应用能否合法的在iOS设备上合法运行。</p>

<h2>四、私钥（private key）</h2>

<p>每个证书（其实是公钥）都对应有一个私钥，</p>

<p>私钥会被用来对代码、资源文件等签名。只有开发证书和描述文件是没办法正常调试的，因为没有私钥根本无法签名。</p>

<p>此后的内容基本都是从<a href="http://objccn.io/issue-17-2/">《代码签名探析》</a>摘抄过来的笔记，建议大家看原文好了。</p>

<h2>五、签名相关命令</h2>

<h4>快捷查看系统中能用来对代码进行签名的证书</h4>

<p>可以使用如下命令：</p>

<p>```
$security find-identity -v -p codesigning<br/>
  1) F10B42FFDE18DF28BA21190121439F2E04BEE4B8 &ldquo;iPhone Developer: weizheng li (P7QJ74LFSA)&rdquo;</p>

<pre><code> 1 valid identities found
</code></pre>

<p>```</p>

<p>这就说明当前有一个同时有公钥和私钥的可用证书。</p>

<h4>对未签名app手动签名</h4>

<p>使用如下命令：</p>

<p><code>
$ codesign -s 'iPhone Developer: Thomas Kollbach (7TPNXN7G6K)' Example.app
</code></p>

<h4>对已签名app重新签名</h4>

<p>为了重新设置签名，你必须带上 -f 参数，有了这个参数，codesign 会用你选择的签名替换掉已经存在的那一个：：</p>

<p><code>
$ codesign -f -s 'iPhone Developer: Thomas Kollbach (7TPNXN7G6K)' Example.app
</code></p>

<h4>查看指定app的签名信息</h4>

<p>codesign 还可以为你提供有关一个可执行文件签名状态的信息，这些信息在出现不明错误时会提供巨大的帮助：</p>

<p><code>
$ codesign -vv -d Example.app
</code>
会列出以下有关 Example.app 的签名信息：</p>

<p><code>
Executable=/Users/toto/Library/Developer/Xcode/DerivedData/Example-cfsbhbvmswdivqhekxfykvkpngkg/Build/Products/Debug-iphoneos/Example.app/Example  
Identifier=ch.kollba.example  
Format=bundle with Mach-O thin (arm64)  
CodeDirectory v=20200 size=26663 flags=0x0(none) hashes=1324+5 location=embedded  
Signature size=4336  
Authority=iPhone Developer: Thomas Kollbach (7TPNXN7G6K)  
Authority=Apple Worldwide Developer Relations Certification Authority  
Authority=Apple Root CA  
Signed Time=29.09.2014 22:29:07  
Info.plist entries=33  
TeamIdentifier=DZM8538E3E  
Sealed Resources version=2 rules=4 files=120  
Internal requirements count=1 size=184  
</code></p>

<h4>验证签名文件的完整性</h4>

<p>检查已签名的文件是否完整可以使用如下命令：</p>

<p><code>
$ codesign --verify Example.app
</code></p>

<p>就像大多数 UNIX 工具一样，没有任何输出代表签名是完好的。如果修改一下这个二进制文件：</p>

<p><code>
$ echo 'lol' &gt;&gt; Example.app/Example
$ codesign --verify Example.app
Example.app: main executable failed strict validation  
</code></p>

<p>和预料中的一样，修改已经签名的应用会导致数字签名验证不通过。</p>

<h2>六、资源文件签名</h2>

<p>iOS 和 OS X 的应用和框架则是包含了它们所需要的资源在其中的。这些资源包括图片和不同的语言文件，资源中也包括很重要的应用组成部分例如 XIB/NIB 文件，存档文件(archives)，甚至是证书文件。所以为一个程序包设置签名时，这个包中的所有资源文件也都会被设置签名。</p>

<p>为了达到为所有文件设置签名的目的，签名的过程中会在程序包（即Example.app）中新建一个叫做 <code>_CodeSignatue/CodeResources</code> 的文件，这个文件中存储了被签名的程序包中所有文件的签名。你可以自己去查看这个签名列表文件，它仅仅是一个 plist 格式文件。</p>

<p>这个列表文件中不光包含了文件和它们的签名的列表，还包含了一系列规则，这些规则决定了哪些资源文件应当被设置签名。伴随 OS X 10.10 DP 5 和 10.9.5 版本的发布，苹果改变了代码签名的格式，也改变了有关资源的规则。如果你使用10.9.5或者更高版本的 codesign 工具，在 CodeResources 文件中会有4个不同区域，其中的 <code>rules</code> 和 <code>files</code> 是为老版本准备的，而 <code>files2</code> 和 <code>rules2</code> 是为新的第二版的代码签名准备的。最主要的区别是在新版本中你无法再将某些资源文件排除在代码签名之外，在过去你是可以的，只要在被设置签名的程序包中添加一个名为 <code>ResourceRules.plist</code> 的文件，这个文件会规定哪些资源文件在检查代码签名是否完好时应该被忽略。但是在新版本的代码签名中，这种做法不再有效。所有的代码文件和资源文件都必须设置签名，不再可以有例外。在新版本的代码签名规定中，一个程序包中的可执行程序包，例如扩展 (extension)，是一个独立的需要设置签名的个体，在检查签名是否完整时应当被单独对待。</p>

<h2>七、授权文件（entitlements）</h2>

<p>在 iOS 上你的应用能做什么依然是沙盒限制的，这些限制大多情况下都由授权文件（entitlements）来决定。授权机制决定了哪些系统资源在什么情况下允许被一个应用使用，简单的说它就是一个沙盒的配置列表。</p>

<p>运行如下命令：</p>

<p><code>
$ codesign -d --entitlements - Example.app
</code></p>

<p>会得到类似的结果：</p>

<p>```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?><br/>
&lt;!DOCTYPE plist PUBLIC &ldquo;&ndash;//Apple//DTD PLIST 1.0//EN&rdquo; &ldquo;<a href="http://www.apple.com/DTDs/PropertyList-1.0.dtd">http://www.apple.com/DTDs/PropertyList-1.0.dtd</a>&rdquo;><br/>
<plist version="1.0"><br/>
<dict></p>

<pre><code>    &lt;key&gt;application-identifier&lt;/key&gt;
    &lt;string&gt;7TPNXN7G6K.ch.kollba.example&lt;/string&gt;
    &lt;key&gt;aps-environment&lt;/key&gt;
    &lt;string&gt;development&lt;/string&gt;
    &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt;
    &lt;string&gt;7TPNXN7G6K&lt;/string&gt;
    &lt;key&gt;com.apple.developer.ubiquity-container-identifiers&lt;/key&gt;
    &lt;array&gt;
            &lt;string&gt;7TPNXN7G6K.ch.kollba.example&lt;/string&gt;
    &lt;/array&gt;
    &lt;key&gt;com.apple.developer.ubiquity-kvstore-identifier&lt;/key&gt;
    &lt;string&gt;7TPNXN7G6K.ch.kollba.example&lt;/string&gt;
    &lt;key&gt;com.apple.security.application-groups&lt;/key&gt;
    &lt;array&gt;
            &lt;string&gt;group.ch.kollba.example&lt;/string&gt;
    &lt;/array&gt;
    &lt;key&gt;get-task-allow&lt;/key&gt;
    &lt;true/&gt;
</code></pre>

<p></dict><br/>
</plist><br/>
<code>``
在 Xcode 的</code>Capabilities<code>选项卡下选择一些选项之后，Xcode 就会生成这样一段 XML。 Xcode 会自动生成一个</code>.entitlements<code>文件，然后在需要的时候往里面添加条目。当构建整个应用时，这个文件也会提交给 codesign 作为应用所需要拥有哪些授权的参考。这些授权信息必须都在开发者中心的 App ID 中启用，并且包含在后文介绍的描述文件中。在构建应用时需要使用的授权文件可以在 Xcode build setting 中的</code>code signing entitlements`中设置。</p>

<p>在新版本的 Xcode 6 之后，授权信息列表会以 Example.app.xcent 这样的名字的文件形式包含在应用包中。这么做或许是为了在出现配置错误时提供更加有用的错误信息。</p>

<h2>八、描述文件（provisioning file）</h2>

<p>在整个代码签名和沙盒机制中有一个组成部分将签名，授权和沙盒联系了起来，那就是描述文件 (provisioning profiles)。</p>

<h4>OS X中保存目录</h4>

<p>Xcode 将从开发者中心下载的全部配置文件都放在了这里：</p>

<p><code>
~/Library/MobileDevice/Provisioning Profiles
</code></p>

<h4>文件格式</h4>

<p>描述文件并不是一个普通的plist文件，它是一个根据密码讯息语法 (Cryptographic Message Syntax) 加密的文件。</p>

<p>以XML格式查看该文件的命令：</p>

<p><code>
$ security cms -D -i example.mobileprovision
</code></p>

<h4>文件内容</h4>

<p>描述文件主要包含以下内容：</p>

<ul>
<li>UUID</li>
</ul>


<p>每一个配置文件都有它自己的 UUID 。Xcode 会用这个 UUID 来作为标识，记录你在 build settings 中选择了哪一个配置文件。</p>

<ul>
<li>ProvisionedDevices</li>
</ul>


<p>记录所有可用于调试的设备ID。</p>

<ul>
<li>DeveloperCertificates</li>
</ul>


<p>包含了可以为使用这个配置文件的应用签名的所有证书。所有的证书都是基于 Base64 编码符合 PEM (Privacy Enhanced Mail, RFC 1848) 格式的。</p>

<ul>
<li>Entitlements</li>
</ul>


<p>有关前面讲到的配置文件的所有内容都会被保存在这里。</p>

<h2>参考文档</h2>

<ul>
<li><p><a href="http://www.objc.io/issue-17/inside-code-signing.html">Inside Code Signing</a></p></li>
<li><p><a href="https://developer.apple.com/legacy/library/technotes/tn2250/_index.html#//apple_ref/doc/uid/DTS40009933-CH1-CODE_SIGNING_IN_A_NUTSHELL">iOS Code Signing Troubleshooting</a></p></li>
<li><p><a href="http://objccn.io/issue-17-2/">代码签名探析</a></p></li>
<li><p><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名是什么？</a></p></li>
<li><p><a href="http://blog.csdn.net/wzzvictory/article/details/9015155">非对称加密原理解析</a></p></li>
<li><p><a href="http://www.2cto.com/Article/201203/122095.html">数字证书原理</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[手动内存管理转ARC项目实战]]></title>
    <link href="http://wangzz.github.io/blog/2014/10/13/shou-dong-nei-cun-guan-li-zhuan-arcxiang-mu-shi-zhan/"/>
    <updated>2014-10-13T16:10:05+08:00</updated>
    <id>http://wangzz.github.io/blog/2014/10/13/shou-dong-nei-cun-guan-li-zhuan-arcxiang-mu-shi-zhan</id>
    <content type="html"><![CDATA[<p>在ARC之前，iOS内存管理无论对资深级还是菜鸟级开发者来说都是一件很头疼的事。我参加过几个使用手动内存管理的项目，印象最深刻的是一个地图类应用，由于应用本身就非常耗内存，当时为了解决内存泄露问题，每周都安排有人值班用Instruments挨个跑功能，关键是每次都总能检查出来不少。其实不管是菜鸟级还是资深级开发者都避免不了写出内存泄露的代码，规则大家都懂，可是天知道什么时候手一抖就少写了个release？</p>

<p>好在项目决定转成ARC了，下面将自己转换的过程和中间遇到的问题写出来和大家共享，希望能减少大家解决同类问题的时间。</p>

<!-- more -->


<h2>一、前言</h2>

<h4>项目简介</h4>

<p>需要转换的Objective-C文件数量：1000个左右。</p>

<p>开发工具：Xcode 6.0.1</p>

<h4>转换方式</h4>

<p>我使用的是Xcode本身提供的ARC转换功能。当然你也可以手动手动转换，那不属于本文范畴，而且其工作量绝对能让你崩溃。</p>

<h2>二、转换过程</h2>

<h4>代码备份</h4>

<p>在进行如此大规模的更改之前，一定要先进行代码备份：直接在本地将代码复制一份，或者记住更改前代码在VCS上的版本号。</p>

<h4>过滤无需转换的文件</h4>

<p>找出项目中引用的仍使用手动内存管理的第三方库，或者某些你不希望转换的文件，对其添加<code>-fno-objc-arc</code>标记。</p>

<p>Xcode自动转换工具只针对Objective-C对象，只会处理<code>Objective-C/Objective-C++</code>即后缀名为<code>.m/.mm</code>的两种文件，因此其他的<code>C/C++</code>对应的<code>.c/.cpp</code>都无需理会。</p>

<h4>执行检查操作</h4>

<p>使用Xcode转换工具入口如图所示：</p>

<p><img src="/images/article8/refactor.png" alt="refactor" /></p>

<p>点击<code>Convert to Objective-C ARC</code>后会进入检查操作入口，如图：</p>

<p><img src="/images/article8/check.png" alt="check" /></p>

<p>该步骤要选择哪些文件需要转换，如果前面将无需转换的文件都添加了<code>-fno-objc-arc</code>标记后，这里可以全选。</p>

<p>点击check按钮后Xcode会帮助我们检查代码中存在的不符合ARC使用规则的错误或警告，只有所有的错误都解决以后才能执行真正的转换操作。</p>

<h4>解决错误/告警</h4>

<p>执行完check操作后，会给出提示：</p>

<p><img src="/images/article8/error.png" alt="error" /></p>

<p>三百多个错误，同时还有一千两百多个警告信息，都要哭了。。。</p>

<p>错误和警告的解决内容较多，后面会单独介绍。</p>

<h4>执行转换操作</h4>

<p>解决完所有的error后，会弹出下述提示界面：</p>

<p><img src="/images/article8/notice.png" alt="notice" /></p>

<p>大意是Xcode将要将你的工程转换成使用ARC管理内存，所有更改的代码在真正更改之前会在一个review界面展示。同时所有的更改完成以后，Xcode会讲项目Target对应的工程设置的使用ARC设置（<code>Objective-C Automatic Reference Counting</code>）会被置成YES（上图右上角的警告标识就是在告诉我们项目已经支持ARC了，但工程中有文件还不支持）：</p>

<p><img src="/images/article8/use_arc.png" alt="use_arc" /></p>

<p>这时离成功就不远了，胜利在望！</p>

<p>点击next按钮后跳转到review界面，样式类似于使用Xcode提交SVN的确认提交界面，如下图所示：</p>

<p><img src="/images/article8/review.png" alt="review" /></p>

<p>该界面列出了所有需要有代码更改的文件，同时能够直接对比转换前和转换后的代码变化。为了稳妥起见，我选择了每个文件都点进去扫了一眼，这也给我们一次机会检查是否漏掉了不能转换的文件。确定一切无误以后，点击右下角的save按钮，一切就大功告成了！</p>

<h2>错误/警告解决</h2>

<h4>错误</h4>

<ul>
<li>ARC forbids synthesizing a property of an Objective-C object with unspecified ownership or storage attribute</li>
</ul>


<p><img src="/images/article8/readonly_error.png" alt="readonly_error" /></p>

<p>property属性必须指定一个内存管理关键字，在属性定义处增加strong关键字即可。</p>

<ul>
<li>ARC forbids explicit message send of &lsquo;release&rsquo;</li>
</ul>


<p><img src="/images/article8/release_error.png" alt="release_error" /></p>

<p>这种情况通常是使用包含release的宏定义，将该宏和使用该宏的地方删除即可。</p>

<ul>
<li>Init methods must return a type related to the receiver type</li>
</ul>


<p><img src="/images/article8/init_return_type.png" alt="init_return_type" /></p>

<p>错误原因是A类里的一个方法以init开头，而且返回的是B类型，好吧，乖乖改方法名。</p>

<ul>
<li>Cast of C pointer type &lsquo;ivPointer&rsquo; (aka &lsquo;void <em>&rsquo;) to Objective-C pointer type &lsquo;iFlyTTSManager_old </em>&rsquo; requires a bridged cast</li>
</ul>


<p><img src="/images/article8/cast_pointer_objective-c.png" alt="cast_pointer_objective-c" /></p>

<p>这是<code>Toll-Free Bridging</code>转换问题，在ARC下根据情况使用对应的转换关键字就行了，后文会专门介绍。</p>

<h4>警告</h4>

<p>解决警告的目的是消除警告处代码存在的隐患，既然Xcode给了提示，那么每一个警告信息都值得我们认真对待。</p>

<ul>
<li>Capturing <code>self</code> in this block is likely to lead to a retain cycle</li>
</ul>


<p><img src="/images/article8/block_capturing_self.png" alt="block_capturing_self" /></p>

<p>这是典型的block循环引用问题，将block中的self改成使用指向self的weak指针即可。</p>

<ul>
<li>Using &lsquo;initWithArray:&rsquo; with a literal is redundant</li>
</ul>


<p><img src="/images/article8/literal_is_redundant.png" alt="literal_is_redundant" /></p>

<p>好吧，原来是没必要的alloc操作，直接按Xcode提示将alloc删除即可：</p>

<p><img src="/images/article8/literal_is_redundant_fix.png" alt="literal_is_redundant_fix.png" /></p>

<ul>
<li>Init methods must return a type related to the receiver type</li>
</ul>


<p><img src="/images/article8/init_methods.png" alt="init_methods.png" /></p>

<p>原来是A类里的一个方法以init开头，而且返回的是B类型，好吧，乖乖改方法名。</p>

<ul>
<li>Property follows Cocoa naming convention for returning ‘owned’ objects</li>
</ul>


<p><img src="/images/article8/property_follows.png" alt="property_follows.png" /></p>

<p>这是因为@property属性的命名以new开头了，可恶。。。修改方法是将对应的getter方法改成非new开头命名的：</p>

<p><img src="/images/article8/property_follows_fix.png" alt="property_follows_fix.png" /></p>

<p>ARC下方法名如果是以new/alloc/init等开头的，而且还不是类的初始化方法，就该小心了，要么报错，要么警告，原因你懂的。</p>

<ul>
<li>Block implicitly retains &lsquo;self&rsquo;; explicitly mention &lsquo;self&rsquo; to indicate this is intended behavior</li>
</ul>


<p><img src="/images/article8/block_implicitly_retains.png" alt="block_implicitly_retains.png" /></p>

<p>意思是block中使用了self的实例变量_selectedModeMarkerView，因此block会隐式的retain住self。Xcode认为这可能会给开发者造成困惑，或者因此而因袭循环引用，所以警告我们要显示的在block中使用self，以达到block显示retain住self的目的。</p>

<p>该警告有两种改法：
①按照Xcode提示，改成self->_selectedModeMarkerView：</p>

<p><img src="/images/article8/block_implicitly_retains_fix1.png" alt="block_implicitly_retains_fix1.png" /></p>

<p>②直接将该警告关闭
警告名称为：<code>Implicit retain of ‘self’ within blocks</code>
对应的Clang关键字是：<code>-Wimplicit-retain-self</code></p>

<p><img src="/images/article8/block_implicitly_retains_fix2.png" alt="block_implicitly_retains_fix2.png" /></p>

<ul>
<li>Weak property may be unpredictably set to nil 和 Weak property &lsquo;delegate&rsquo; is accessed multiple times in this method but may be unpredictably set to nil; assign to a strong variable to keep the object alive</li>
</ul>


<p><img src="/images/article8/weak_property_unpredictably.png" alt="weak_property_unpredictably.png" /></p>

<p>这是工程中数目最多的警告，这是因为所有的delegate属性都是weak的，Xcode默认开启了下图中的两个警告设置，将其关闭即可：</p>

<p><img src="/images/article8/weak_property_unpredictably_fix.png" alt="weak_property_unpredictably_fix.png" /></p>

<ul>
<li>Capturing &lsquo;self&rsquo; strongly in this block is likely to lead to a retain cycle</li>
</ul>


<p><img src="/images/article8/retain_cycle.png" alt="retain_cycle.png" /></p>

<p>这是明显的block导致循环引用内存泄露的情况，之前代码中坑啊！修改方案：</p>

<p><img src="/images/article8/retain_cycle_fix.png" alt="retain_cycle_fix.png" /></p>

<ul>
<li>Method parameter of type &lsquo;NSError <em>__autoreleasing </em>&rsquo; with no explicit ownership</li>
</ul>


<p><img src="/images/article8/autorelease_error.png" alt="autorelease_error.png" /></p>

<p>这种就不用说了，按警告中的提示添加<code>__autoreleasing</code>关键字即可。</p>

<p>以上列出的错误和警告只是数量较多的，还有很多其他就不在这里一一列举了。</p>

<p>另外，推荐  <a href="https://twitter.com/mattt">Mattt Thompson</a> 大神关于Clang中几乎所有warning的名称和对应报错提示语的网站：<a href="http://fuckingclangwarnings.com/">http://fuckingclangwarnings.com/</a>，以后解决warning类问题就简单多了！</p>

<h2>Xcode自动转换</h2>

<h4>关键字转换</h4>

<p>Xcode会自动将某些关键字自动转换成ARC的对应版本。</p>

<ul>
<li>retain自动转成strong，如图：</li>
</ul>


<p><img src="/images/article8/retain_strong.png" alt="retain_strong.png" /></p>

<ul>
<li>assign关键字转成weak</li>
</ul>


<p>修饰Objective-C对象或者id类型对象的assign关键字会被转成weak，如图：</p>

<p><img src="/images/article8/assign_weak.png" alt="assign_weak.png" /></p>

<p>但是修饰Int/bool等数值型变量的assign不会自动转换成weak，如图：</p>

<p><img src="/images/article8/assign_not_weak.png" alt="assign_not_weak.png" /></p>

<h4>关键字删除</h4>

<p>和手动内存管理相关的几个关键字，比如：<code>release/retain/autorelease/super dealloc</code>等会被删除；</p>

<p>dealloc方法中如果除了release/super dealloc语句外，如果别的代码，dealloc方法会保留,如图：</p>

<p><img src="/images/article8/retain_dealloc.png" alt="retain_dealloc.png" /></p>

<p>如果没有整个方法都会被删除：</p>

<p><img src="/images/article8/delete_dealloc.png" alt="delete_dealloc.png" /></p>

<h4>关键字替换</h4>

<ul>
<li>在转换时<strong>block关键字会被自动替换成</strong>weak：</li>
</ul>


<p><img src="/images/article8/block_weak.png" alt="block_weak.png" /></p>

<ul>
<li>@autoreleasepool</li>
</ul>


<p>NSAutoreleasePool不支持ARC，会被替换成@autoreleasepool：</p>

<p><img src="/images/article8/autoreleasepool.png" alt="autoreleasepool.png" /></p>

<h4>关于被宏注释代码</h4>

<ul>
<li>使用宏定义的对象释放代码</li>
</ul>


<p>宏定义如下所示：</p>

<p>```objective-c</p>

<h1>define RELEASE_SAFELY(__POINTER) { \</h1>

<p>[(<strong>POINTER) release]; (</strong>POINTER) = nil; }
```
在执行ARC转换检查操作时，Xcode会在使用该宏的地方报错：</p>

<p><img src="/images/article8/release_error.png" alt="release_error.png" /></p>

<p>将该宏和使用该宏的地方删除即可。</p>

<ul>
<li>被宏注释掉的代码，Xcode在转换时是不会处理的，如图：</li>
</ul>


<p><img src="/images/article8/marco_arc.png" alt="marco_arc.png" /></p>

<p>PS：这是相当坑的一点，因为你根本预料不到工程中使用了多少宏，注释掉了多少代码。当你执行完转换操作，以为就大功告成的时候，却在某天因为一个宏的开启遇到了一堆新的转ARC不彻底的问题。这种问题也没招，只能遇到一个改一个了。</p>

<h2>ARC和block</h2>

<p>不管是手动内存管理还是ARC，block循环引用导致的内存泄露都是一个令人头疼的问题。在MRC中，解决block循环引用只需要使用__block关键字，在ARC下解决与block的使用就略显复杂了：</p>

<h4>__block关键字</h4>

<ul>
<li>block内修改外部定义变量</li>
</ul>


<p>和手动内存管理一样，ARC如果在block中需要修改block之外定义的变量需要使用<code>__block</code>关键字修饰，比如：</p>

<p>```objective-c
__block NSString *name = @&ldquo;foggry&rdquo;;
self.expireCostLabel.completionBlock = ^(){</p>

<pre><code>name = @"wangzz";
</code></pre>

<p>};
```</p>

<p>上例中name变量需要在block中修改，因此必须使用__block关键字。</p>

<ul>
<li>__block在MRC和ARC中的区别</li>
</ul>


<p>在ARC下的block中使用__block关键字修饰的对象时，block会retain该对象；而在MRC下却不会retain。关于这点在官方文档<a href="https://developer.apple.com/library/ios/releasenotes/objectivec/rn-transitioningtoarc/introduction/introduction.html">Transitioning to ARC Release Notes</a>中有详细的描述：</p>

<blockquote><p>In manual reference counting mode, <strong>block id x; has the effect of not retaining x.
In ARC mode, </strong>block id x; defaults to retaining x (just like all other values).</p></blockquote>

<p>下面的代码不管在MRC还是ARC中<code>myController</code>对象都是有内存泄露的：</p>

<p><code>objective-c
MyViewController *myController = [[MyViewController alloc] init…];
// ...
myController.completionHandler =  ^(NSInteger result) {
   [myController dismissViewControllerAnimated:YES completion:nil];
};
</code></p>

<p>内存泄露问题在MRC中可以按如下方式更改：</p>

<p>```objective-c
MyViewController * __block myController = [[MyViewController alloc] init…];<br/>
// &hellip;<br/>
myController.completionHandler =  ^(NSInteger result) {</p>

<pre><code>[myController dismissViewControllerAnimated:YES completion:nil];  
</code></pre>

<p>};
```</p>

<p>然而在ARC中这么改就不行了。正如开始所说的那样，在ARC中<code>myController.completionHandler</code>的block会retain<code>myController</code>对象，使得内存泄露问题仍然存在！！</p>

<p>在ARC中该问题有两种解决方案，第一种：</p>

<p>```objective-c
MyViewController * __block myController = [[MyViewController alloc] init…];<br/>
// &hellip;<br/>
myController.completionHandler =  ^(NSInteger result) {</p>

<pre><code>[myController dismissViewControllerAnimated:YES completion:nil];  
myController = nil;  
</code></pre>

<p>};
```
该方法在block中使用完myController时，是它指向nil。没有strong类型的指针指向myController指向的对象时，对象会被释放掉。</p>

<p>第二种种解决方案，直接使用<strong>weak代替</strong>block关键字：</p>

<p>```objective-c
MyViewController *myController = [[MyViewController alloc] init…];<br/>
// &hellip;<br/>
MyViewController * __weak weakMyViewController = myController;<br/>
myController.completionHandler =  ^(NSInteger result) {</p>

<pre><code>[weakMyViewController dismissViewControllerAnimated:YES completion:nil];  
</code></pre>

<p>};
```
该方法直接避免了对block对myController对象的retain。</p>

<h4>存在循环引用关系</h4>

<p>如果self直接或者间接的对block存在强引用，在block中又需要使用self关键字，此时self和block就存在循环引用的关系。此时必须使用__weak关键字定义一个指针指向self，在block中使用该指针来引用self：</p>

<p>```objective-c
MessageListController * __weak weakSelf = self;
self.messageLogic.loadMoreBlock = ^(IcarMessage * theMessage) {</p>

<pre><code>[weakSelf.tableView setPullTableIsLoadingMore:YES];
</code></pre>

<p>};
```</p>

<p>需要说明的是，尽管上例中weakSelf指针对self只是弱引用，但是self对block却是强引用，self的生命周期一定是长于block的，因此不用担心在block中使用weakSelf指针时，其指向的self会被释放掉。</p>

<h4>不存在循环引用关系</h4>

<p>下面的例子：</p>

<p>```objective-c
MyViewController *myController = [[MyViewController alloc] init…];
// &hellip;
MyViewController * __weak weakMyController = myController;
myController.completionHandler =  ^(NSInteger result) {</p>

<pre><code>MyViewController *strongMyController = weakMyController;
if (strongMyController) {
    // ...
    [strongMyController dismissViewControllerAnimated:YES completion:nil];
    // ...
}
else {
    // Probably nothing...
}
</code></pre>

<p>};
```</p>

<p>如前面所说，<code>myController.completionHandler</code>的block中不能直接使用<code>myController</code>对象，会造成内存泄露，因此需要先用一个weak的指针指向<code>myController</code>对象，然后在block中使用该weak指针。但是为了确保在block执行的时候<code>myController</code>对象没有被释放掉，就在block一开始的地方定义了一个临时的strong类型的指针<code>strongMyController</code>指向weak指针<code>weakMyController</code>，其实最终的结果就是block中对<code>myController</code>对象强引用了。在block执行完被销毁的时候，<code>strongMyController</code>指针变量会被销毁，其最终指向的<code>myController</code>对象因此也会被销毁。这样在使用一个对象的时候做就保证了该对象是存在的，使用完了再放弃该对象的所有权。</p>

<h2>ARC和Toll-Free Bridging</h2>

<p>MRC下的<code>Toll-FreeBridging</code>不涉及内存管理的转移，Objective-C（后文简称OC）和Core Foundation（后文简称CF）各自管理各自的内存,相互之间可以直接交换使用，比如：</p>

<p><code>objective-c
NSLocale *gbNSLocale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_GB"];
CFLocaleRef gbCFLocale = (CFLocaleRef)gbNSLocale;
</code></p>

<p>而在ARC下,事情就会变得复杂一些。因为ARC能够管理OC对象的内存,却不能管理CF对象,CF对象依然需要我们手动管理内存。在CF和OC之间bridge对象的时候,问题就出现了,编译器不知道该如何处理这个同时有OC指针和CF指针指向的对象。这时候,需要使用<code>__bridge</code>, <code>__bridge_retained</code>, <code>__bridge_transfer</code>等修饰符来告诉编译器该如何去做。</p>

<ul>
<li>__bridge</li>
</ul>


<p>它告诉编译器仍然负责管理好在OC一端的引用计数的事情,开发者也继续负责管理好在CF一端的事情，比如：</p>

<p><code>objective-c
CFStringRef cfString = CFStringCreateWithCString(kCFAllocatorDefault, "CFString", kCFStringEncodingUTF8);
NSString *ocString = (__bridge NSString *)cfString;
CFRelease(cfString);
NSLog(@"%@",ocString);
</code></p>

<ul>
<li>__bridge_retained 或 CFBridgingRetain</li>
</ul>


<p>二者作用是一样的，只是用法不同。</p>

<p>告诉编译器需要retain对象,而开发者在CF一端负责释放。这样就算对象在OC一端被释放,只要开发者不释放CF一端的对象, 对象就不会被真的销毁。</p>

<p><code>objective-c
NSArray *ocArray = [[NSArray alloc] initWithObjects:@"foggry", nil];
CFArrayRef cfArray = (__bridge_retained CFArrayRef)ocArray;
/**
 使用cfArray
 **/
CFRelease(cfArray);
</code></p>

<ul>
<li>__bridge_transfer 或 CFBridgingRelease</li>
</ul>


<p>二者作用也是一样的，只是用法不同。</p>

<p>该关键字告诉编译器bridge的同时,也转移了对象的所有权，比如：</p>

<p><code>objective-c
CFStringRef cfString = CFStringCreateWithCString(kCFAllocatorDefault, "CFString", kCFStringEncodingUTF8);
NSString *ocString = (__bridge_transfer NSString *)cfString;
//CFRelease(cfString); //不再需要释放操作
NSLog(@"%@",ocString);
</code></p>

<p>转换过程中大家只需要根据具体需求选用适当的关键字即可。</p>

<p>另外，在ARC中<code>id</code>和<code>void *</code>也不能直接相互转换了，必须通过<code>Toll-FreeBridging</code>使用适当的关键字修饰。</p>

<h2>ARC和IBOutLet</h2>

<p>对于IBOutLet属性应该用strong还是weak一直都有疑惑。关于这一点<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW6">官方文档</a>是这么介绍的：</p>

<blockquote><p>From a practical perspective, in iOS and OS X outlets should be defined as declared properties. Outlets should generally be weak, except for those from File’s Owner to top-level objects in a nib >>>file (or, in iOS, a storyboard scene) which should be strong. Outlets that you create should therefore typically be weak.</p></blockquote>

<p>那么长的一段英文想说的是：</p>

<p>如果nib文件构建的view是直接被Controller引用的顶层view，对应的IBOutLet属性应该是strong；</p>

<p>如果view是顶层view上的一个子view，那么该view的属性应该是weak，因为顶层view被Controller使用strong属性引用了，而顶层view本身又持有该view；</p>

<p>如果Controller对某个view需要单独引用，或者Controller没有引用某个view的父view，那么其属性也应该是strong。</p>

<p>好吧，其实我能说如果你实在懒得区分什么时候用strong，什么时候用weak，那就将所以后的IBOutLet属性都设成strong吧！在Controller销毁的时候，对应的IBOutLet实例变量也会被销毁，strong指针会被置成nil，因此也不会有内存问题。</p>

<h2>参考文档</h2>

<ul>
<li><a href="https://developer.apple.com/library/ios/releasenotes/objectivec/rn-transitioningtoarc/introduction/introduction.html">Transitioning to ARC Release Notes</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW6">Managing the Lifetimes of Objects from Nib Files</a></li>
<li><a href="https://mikeash.com/pyblog/friday-qa-2012-04-13-nib-memory-management.html">Nib Memory Management</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iPhone屏幕知识点解析]]></title>
    <link href="http://wangzz.github.io/blog/2014/09/28/iphoneping-mu-zhi-shi-dian-jie-xi/"/>
    <updated>2014-09-28T14:34:37+08:00</updated>
    <id>http://wangzz.github.io/blog/2014/09/28/iphoneping-mu-zhi-shi-dian-jie-xi</id>
    <content type="html"><![CDATA[<p><img src="/images/article7/iphone5-6.jpg" alt="iphone5-6" /></p>

<h2>一、屏幕相关知识点</h2>

<h4>1、屏幕尺寸</h4>

<p>在显示器世界里，屏幕尺寸都是由屏幕对角线长度表示的，单位是英寸。比如iPhone4的3.5寸屏就意味着屏幕对角线的长度是3.5英寸。</p>

<h4>2、分辨率</h4>

<p>分辨率是任何一款手机产品最重要的参数之一。显示屏是由一个个像素组成的，分辨率可以简单理解成屏幕像素的数目。比如iPhone4的屏幕分辨率为640×960，就表示屏幕的横向有640个像素点，纵向有960个像素点。</p>

<!-- more -->


<h4>3、PPI</h4>

<p>PPI（Pixels Per Inch）表示单位面积上的像素点数目。分辨率可以表示屏幕包含的像素数目，但要想描述屏幕的显示质量，还需要知道屏幕尺寸，最后算出单位面积上的像素点数目。显然PPI越高，屏幕显示效果越细腻。</p>

<p>PPI计算公式：</p>

<p><img src="/images/article7/PPI.jpg" alt="PPI" /></p>

<p>其中，X：长度像素数；Y：宽度像素数；Z：屏幕尺寸即对角线长度</p>

<h4>4、Points</h4>

<p>可以简单理解成我们使用<code>UIKit</code>或 <code>Core Animation</code>处理界面元素时所用到的逻辑坐标系统。Points是在iOS4以后引入的，出现的目的是提供一种与设备无关的一致的输出效果。</p>

<p>苹果考虑到以后有可能推出不同分辨率屏幕的手机，如果开发者在界面布局的时候操纵像素，就会导致每种不同分辨率的设备都要有一份适配代码。比如在分辨率为320×480的iPhone3GS上，要画一条长度1英寸的线条，假设需要50个像素，即线条的长度设成50像素；但是在分辨率为640×960的iPhone4上，50像素所能表示的实际长度只有iPhone3GS的一半，即0.5英寸。因此开发者必须使用两套适配代码：在iPhone3GS上将线条长度设成50像素，在iPhone4上设成100像素。这还仅仅是两款设备，如果算上后来的iPhone5/5C/5S和iPhone6/6+，每种分辨率都来一套适配代码，开发者岂不是得疯掉？？</p>

<p>现在苹果使用了一套逻辑坐标系统来解决多分辨率屏幕适配问题，将屏幕上的每一个点都用以屏幕左上角为原点，横向为X轴，纵向为Y轴的坐标来表示（PS：并不是所有的框架默认坐标系统都是这样，比如<code>APPKit</code>中的<code>NSView</code>；当然开发者也可以将<code>UIKit</code>和 <code>Core Animation</code>的坐标系统改成以屏幕左下角为原点，但原理都是一样的。）。以iPhone3GS/4为例，他们的坐标系统中X和Y的最大值都分别是320和480。</p>

<p>有了逻辑坐标系统，想在分辨率不同的iPhone3GS/4画一条长度均为1英寸的线条就变成了这样：将线的长度设成50Points（假设1英寸对应那么多个Points），<code>UIKit</code>在屏幕上绘图的时候会判断屏幕分辨率，如果是iPhone3GS的320×480分辨率屏幕，会自动使用50像素绘制；如果是iPhone4的640×960分辨率，会自动使用100像素绘制。</p>

<p>这种机制使得在4寸屏幕的iPhone5出来之前，iOS开发者在设备屏幕适配上的工作量几乎为零（当然，需要准备两套图片），对此Android同行们早就口水直下三千尺了。后来随着iPhone屏幕尺寸的变化，逻辑坐标系统的取值范围也发生了变化，这才让iOS开发者有点事情可做。</p>

<h4>5、渲染比例（Scale）</h4>

<p>像素点数目和逻辑坐标点数目的比值，就是渲染比例（Scale）。更直观的说法是一个逻辑坐标点，需要用几个像素点来渲染。</p>

<p>iPhone3GS的逻辑坐标系统是320×480，分辨率是320×480，即每个坐标点对应一个像素，即Scale为1；iPhone4的逻辑坐标系统是320×480，分辨率是640×960，每个坐标点对应两个像素点，即Scale为2。</p>

<p>因此，为了适配iPhone6+的屏幕，以后又得曾加一份@3x分辨率的图片了。</p>

<h4>6、宽高比</h4>

<p>屏幕宽度和高度的比例，也可以是分辨率的横向像素点数目和纵向像素点数目的比例，他们通常是一致的，一般用整数表示。</p>

<p>iPhone3GS/4/4S的宽高比2:3，iPhone5/5C/5S/6/6+的宽高比都是9:16。</p>

<p>当年iPhone5出来的时候，适配3.5寸屏幕的应用上下黑边的场景仍记忆犹新，用户体验很不好，虽然大部分应用都迅速的做了适配。还好苹果这次学聪明了，从4寸屏升级到iPhone6的4.7寸屏和iPhone6+的5.5寸屏，宽高比并没有变化。也就是说原来在iPhone5上运行的应用能够通过拉伸平滑过渡到iPhone6/6+上，可能会稍微有点模糊。不过比起3.5寸到4寸屏的升级来说已经好很多了。</p>

<h2>二、说明</h2>

<h4>1、历代iPhone屏幕参数</h4>

<p>下面的一张图介绍了从iPhone4到iPhone6+的几代iPhone跟屏幕相关的几个关键参数：</p>

<p><img src="/images/article7/iPhone_display.png" alt="iPhone_display" /></p>

<p>需要说明的是，iPhone6+的逻辑坐标是414×736，渲染比例是3倍，因此对应的屏幕分辨率是1242×2208。但iPhone6+的实际屏幕分辨率是1080×1920，这时系统会把整体的显示内容做一个从新采样缩放，downsampling比例为1/1.15。</p>

<h4>2、老工程中的坐标系统</h4>

<p>使用Xcode6之前版本的Xcode创建的工程，在iPhone6/6+上运行，得到的逻辑坐标都是和iPhone5/5C/5S屏幕相同的320*568。这样就做到从4寸到4.7寸和5.5寸屏幕的无缝升级，即使我们什么都不做，我们的老工程也能在iPhone6/6+上几乎完美的运行。当然因为等比例放大了，图片可能会有模糊或锯齿感。</p>

<p>要想让老工程的坐标系统恢复正常，可以通过为Target添加<code>LaunchImage</code>或者<code>Launch Screen File</code>来实现，如下图所示：</p>

<p><img src="/images/article7/LaunchFile.png" alt="LaunchFile" /></p>

<p><code>LaunchImage</code>的方式需要在<code>Images.xcassets</code>里，删除旧的<code>LaunchImage</code>组，然后新建<code>LaunchImage</code>组，添加对应高分辨率的图片。对此，这里有一篇更详细的图文介绍：<a href="http://matthewpalmer.net/blog/2014/09/10/iphone-6-plus-launch-image-adaptive-mode/">How to Add a Launch Image for the iPhone 6</a>。</p>

<p>其中<code>Launch Screen File</code>是Xcode6和iOS8新加的功能，它用一个xib文件来作为启动画面。App在旧版iOS启动时，该属性会被自动忽略，不会造成异常。</p>

<p>上面两种设置，只要启用任意一个即可让App进入高分辨率模式。鉴于现在不少App还需要兼容iOS5，而第一种方法在iOS5上可能有<a href="http://stackoverflow.com/questions/19220082/support-of-ios-5-0-icons-with-xcode-5">bug</a>，所以这里推荐用第二种方法。</p>

<h2>三、参考文档</h2>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingios/GraphicsDrawingOverview/GraphicsDrawingOverview.html">Drawing and Printing Guide for iOS</a></li>
<li><a href="http://baike.baidu.com/view/7687.htm">分辨率</a></li>
<li><a href="http://blog.ibireme.com/2014/09/16/adapted_to_iphone6/#rd?sukey=f3735aed1ca7f2658e86e2e18cb36d80fed889a7bdfd2d651a1aaef8f9941b691c71e4e8353e61cd57237e4cd0b3edc6#jtss-tsina">大屏iPhone的适配</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreAnimation系列之基础变换]]></title>
    <link href="http://wangzz.github.io/blog/2014/08/27/coreanimationxi-lie-zhi-ji-chu-bian-huan/"/>
    <updated>2014-08-27T12:21:50+08:00</updated>
    <id>http://wangzz.github.io/blog/2014/08/27/coreanimationxi-lie-zhi-ji-chu-bian-huan</id>
    <content type="html"><![CDATA[<p>从<a href="http://blog.csdn.net/wzzvictory">CSDN</a>时代开始，就有用一系列文章聊聊CoreAnimation的打算，这算是本系列中的第三篇了。一直以来都是哪天心情好的时候来一篇，真怀疑等把整个系列写完的时候CoreAnimation是不是都要被Apple换掉了。</p>

<p>本文打算介绍自己对基础变换的认识。</p>

<h2>一、基础变换与数学</h2>

<h4>1.两种坐标系</h4>

<p>不管是平面几何还是立体几何，笛卡尔坐标系都是我们学习和研究几何的最基础工具。的笛卡尔坐标系主要分两种：左手坐标系和右手坐标系。</p>

<p>对于三维坐标系，<a href="http://baike.baidu.com/view/2939423.htm">百度百科</a>上给出了右手坐标系的判断方法：在空间直角坐标系中，让右手拇指指向x轴的正方向，食指指向y轴的正方向，如果中指能指向z轴的正方向，则称这个坐标系为右手直角坐标系。同理左手直角三维坐标系。</p>

<!-- more -->


<p>下图直观的表示了上述判断方法（图片来自<a href="http://outofmemory.cn/wr/?u=http%3A%2F%2Fwonderffee.github.io%2Fblog%2F2013%2F10%2F17%2Fa-simple-method-to-determine-positive-rotation-in-in-three-dimensional-space%2F">这里</a>）：</p>

<p><img src="/images/article6/coordinate-system.jpg" alt="left-right hand coordinate" /></p>

<p>由此判断，从中学到大学的课堂上我们接触的立体几何都是右手系。</p>

<h4>2.基础变换的数学公式</h4>

<p>一个点在立体空间内的变换可以通过数学公式表示，前面讲那么多左手和右手坐标系相关的内容是因为<code>不同坐标系下计算公式不同</code>。</p>

<p>iOS中CoreAnimation的CALayer默认使用的是<code>左手坐标系</code>（使用哪种坐标系可以通过CALayer的<code>geometryFlipped</code>属性更改，该值默认为NO，设为YES时表示使用右手坐标系），因此本文后面所说的所有坐标系都是之左手坐标系。</p>

<p>变换对于动画来说应该是最基础最核心的内容了，CoreAnimation中基础变换包括平移（Translate）、缩放（Scale）、旋转（Rotate）三种。假如三维空间中有一个点(x0, y0, z0)，该点经过一定条件的基础变换，变换后的坐标为(x, y, z)，则针对平移、缩放、旋转三种基础变换，对应的坐标变换关系如下：</p>

<h6>2.1 平移</h6>

<p>平移对应的变化量为(δx, δy, δz)。</p>

<p><code>
x = x0 + δx;
y = y0 + δy;
z = z0 + δz;
</code></p>

<h6>2.2 缩放</h6>

<p>缩放对应的缩放倍数为(δx, δy, δz)。</p>

<p><code>
x = x0 * δx;
y = y0 * δy;
z = z0 * δz;
</code></p>

<h6>2.3 旋转</h6>

<p>旋转的方式有很多，比如简单点的绕X轴、Y轴、Z轴旋转，复杂点的还有绕任意三维向量旋转。为了简单起见，旋转以绕Z轴旋转了角度α（注意这里及后文所有涉及角度的地方都是弧度制）为例，对应的变化关系为：</p>

<p><code>
x = y0*sinα + x0*cosα;
y = y0*conα - x0*sinα;
z = z0;
</code></p>

<p>其它的大家感兴趣可以自己推倒下。</p>

<h2>二、变换矩阵</h2>

<p>在CoreAnimation中用CATransform3D来表示三维齐次坐标变换矩阵，在齐次坐标中n维空间的坐标需要用n+1个元素的坐标元组来表示（详情还请自行Google），因此CATransform3D定义如下：</p>

<p><code>
struct CATransform3D
{
  CGFloat m11, m12, m13, m14;
  CGFloat m21, m22, m23, m24;
  CGFloat m31, m32, m33, m34;
  CGFloat m41, m42, m43, m44;
};
</code>
为什么实现变换要有变换矩阵呢？</p>

<p>以上文中旋转的计算公式为例，可以使用如下矩阵运算表示：</p>

<p><img src="/images/article6/matrix1.png" alt="left-right hand coordinate" /></p>

<p>其中的矩阵：</p>

<p><img src="/images/article6/matrix2.png" alt="left-right hand coordinate" /></p>

<p>就被称为点(x0, y0, z0)绕Z轴旋转角度α的变换矩阵。</p>

<p>由于放射变换可以通过矩阵变换来实现，而且看起来更加直观，因此变换公式通常都用对应的变换矩阵表示。</p>

<p>在CoreAnimation中平移、缩放、旋转对应的变换矩阵为：</p>

<h4>1. 平移</h4>

<p><img src="/images/article6/matrix3.png" alt="left-right hand coordinate" /></p>

<p>其中δx、δy、δz表示三个坐标上对应的平移量。</p>

<h4>2. 缩放</h4>

<p><img src="/images/article6/matrix4.png" alt="left-right hand coordinate" /></p>

<p>其中δx、δy、δz表示三个坐标上对应的缩放倍数。</p>

<h4>3. 旋转</h4>

<p><img src="/images/article6/matrix5.png" alt="left-right hand coordinate" /></p>

<p>该矩阵为任意点(x, y, z)绕任意向量旋转旋转角度α的旋转向量。</p>

<h2>三、验证</h2>

<p>前面总结了CoreAnimation中三种基础变换对应的变换矩阵，这样以来我们就能自己对任意的矩阵做变换了。平移、缩放、旋转对应的变换矩阵计算方法如下：</p>

<h4>1. 平移</h4>

<p>```objective-c
&ndash; (CATransform3D)translateWithMatrix:(CATransform3D)t x:(CGFloat)x y:(CGFloat)y z:(CGFloat)z
{</p>

<pre><code>CATransform3D matrixTransform = CATransform3DIdentity;
matrixTransform.m41 = x;
matrixTransform.m42 = y;
matrixTransform.m43 = z;

return CATransform3DConcat(matrixTransform, t);
</code></pre>

<p>}
```</p>

<p>该方法根据平移变换矩阵的计算方式，得到平移参数(x, y, z)对应的变换矩阵，然后和原始矩阵相乘，得到最终的变换矩阵。</p>

<h4>2. 缩放</h4>

<p>```objective-c
&ndash; (CATransform3D)scaleWithMatrix:(CATransform3D)t x:(CGFloat)x y:(CGFloat)y z:(CGFloat)z
{</p>

<pre><code>CATransform3D matrixTransform = CATransform3DIdentity;
matrixTransform.m11 = x;
matrixTransform.m22 = y;
matrixTransform.m33 = z;

return CATransform3DConcat(matrixTransform, t);
</code></pre>

<p>}
```</p>

<p>该方法根据缩放变换矩阵的计算方式，得到缩放参数(x, y, z)对应的变换矩阵，然后和原始矩阵相乘，得到最终的变换矩阵。</p>

<h4>3. 旋转</h4>

<p>```objective-c
&ndash; (CATransform3D)rotateWithMatrix:(CATransform3D)t angle:(CGFloat)angle x:(CGFloat)x y:(CGFloat)y z:(CGFloat)z
{</p>

<pre><code>CGFloat unitValue = sqrtf(powf(x, 2)+powf(y, 2)+powf(z, 2));
CGFloat x0 = x/unitValue;
CGFloat y0 = y/unitValue;
CGFloat z0 = z/unitValue;

CATransform3D matrixTransform = CATransform3DIdentity;
matrixTransform.m11 = powf(x0, 2)*(1-cosf(angle))+cosf(angle);
matrixTransform.m12 = x0*y0*(1-cosf(angle))+z0*sinf(angle);
matrixTransform.m13 = x0*z0*(1-cosf(angle))-y0*sinf(angle);

matrixTransform.m21 = x0*y0*(1-cosf(angle))-z0*sinf(angle);
matrixTransform.m22 = powf(y0, 2)*(1-cosf(angle))+cosf(angle);
matrixTransform.m23 = y0*z0*(1-cosf(angle))+x0*sinf(angle);

matrixTransform.m31 = x0*z0*(1-cosf(angle))+y0*sinf(angle);
matrixTransform.m32 = y0*z0*(1-cosf(angle))-x0*sinf(angle);
matrixTransform.m33 = powf(z0, 2)*(1-cosf(angle))+cosf(angle);

return CATransform3DConcat(matrixTransform, t);
</code></pre>

<p>}
```</p>

<p>该方法根据旋转变换矩阵的计算方式，得到旋转参数(angle, x, y, z)对应的变换矩阵，然后和原始矩阵相乘，得到最终的变换矩阵。</p>

<h4>4. demo</h4>

<p>以旋转变换demo为例：</p>

<p>```objective-c
&ndash; (void)logTransform:(CATransform3D)t
{</p>

<pre><code>NSLog(@"***************************");
NSLog(@"%f,%f,%f,%f",t.m11,t.m12,t.m13,t.m14);
NSLog(@"%f,%f,%f,%f",t.m21,t.m22,t.m23,t.m24);
NSLog(@"%f,%f,%f,%f",t.m31,t.m32,t.m33,t.m34);
NSLog(@"%f,%f,%f,%f",t.m41,t.m42,t.m43,t.m44);
</code></pre>

<p>}</p>

<ul>
<li><p>(IBAction)onRotateButtonAction:(id)sender
{
  //Rotate</p>

<p>  //随意的原始矩阵
  CATransform3D matrixOrigin = CATransform3DMakeRotation(1, 4, 3, 6);</p>

<p>  CGFloat x = 2, y = 3, z = 4; //旋转向量（2,3,4）
  CGFloat angle = 30.0f * M_PI / 180.0f; //旋转角度30°，计算对应的弧度</p>

<p>  //通过系统函数计算变换矩阵
  CATransform3D matrixSystem = CATransform3DRotate(matrixOrigin, angle, x, y, z);
  systemLayer.transform = matrixSystem;
  [self logTransform:matrixSystem];</p>

<p>  //自定义方法计算3D旋转矩阵
  CATransform3D matrixCalculate = [self rotateWithMatrix:matrixOrigin angle:angle x:x y:y z:z];
  customLayer.transform = matrixCalculate;
  [self logTransform:matrixCalculate];
}
```</p></li>
</ul>


<p>demo使用随意生成的参数<code>matrixOrigin</code>模拟一个CALayer的初始<code>transform</code>属性值，然后使用同一组变换参数，分别通过系统函数和自定义方法对原始<code>transform</code>做变换，然后对比变换结果。最终的计算得到的变换矩阵可以通过log的方式打印出来，也可以在界面上做直观的展示。</p>

<p>平移和缩放变换矩阵的验证方式和旋转类似。</p>

<p>经过对比发现两种计算方式得到的最终变换矩阵是完全相同的，这进一步验证了CoreAnimation中变换矩阵的计算方式。</p>

<p>完整的<a href="https://github.com/wangzz/Demo/tree/master/CoreAnimationDemo">demo</a>放到了github上，欢迎大家下载。</p>

<h2>四、说明</h2>

<ul>
<li>变换矩阵可以组合</li>
</ul>


<p>可以同时对CALayer进行多种变换，比如同时缩放和旋转，直接通过矩阵相乘得到组合变换的变换矩阵。CoreAnimation提供了变换矩阵组合的方法：</p>

<p><code>objective-c
CATransform3D CATransform3DConcat (CATransform3D a, CATransform3D b)
</code>
需要注意的是，通常情况下矩阵乘法不支持交换律，因此两个矩阵a、b的顺序不能交换。</p>

<ul>
<li>最好不要手动修改变换矩阵的值</li>
</ul>


<p>CoreAnimation的3D变换对应的4维变换矩阵，单独修改其中的任何一个值都可能带来不可控的变换结果，因此不建议单独手动修改变换矩阵，而是通过基础变换或者基础变换组合的方式修改。</p>

<ul>
<li>理解有误的地方还望大家指出。</li>
</ul>


<h2>五、参考文档</h2>

<ul>
<li><a href="http://www.thinkandbuild.it/introduction-to-3d-drawing-in-core-animation-part-2/">INTRODUCTION TO 3D DRAWING IN CORE ANIMATION</a></li>
<li><a href="http://en.wikipedia.org/wiki/Rotation_matrix">Rotation matrix</a></li>
<li><a href="http://baike.baidu.com/view/2939423.htm">右手坐标系</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
