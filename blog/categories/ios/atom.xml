<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 王中周的技术博客]]></title>
  <link href="http://wangzz.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://wangzz.github.io/"/>
  <updated>2014-10-13T16:25:16+08:00</updated>
  <id>http://wangzz.github.io/</id>
  <author>
    <name><![CDATA[王中周]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[手动内存管理转ARC项目实战]]></title>
    <link href="http://wangzz.github.io/blog/2014/10/13/shou-dong-nei-cun-guan-li-zhuan-arcxiang-mu-shi-zhan/"/>
    <updated>2014-10-13T16:10:05+08:00</updated>
    <id>http://wangzz.github.io/blog/2014/10/13/shou-dong-nei-cun-guan-li-zhuan-arcxiang-mu-shi-zhan</id>
    <content type="html"><![CDATA[<p>在ARC之前，iOS内存管理无论对资深级还是菜鸟级开发者来说都是一件很头疼的事。我参加过几个使用手动内存管理的项目，印象最深刻的是<code>高德地图</code>。由于地图类应用本身就非常耗内存，当时为了解决内存泄露问题，每周都安排有人值班用Instruments挨个跑功能，关键是每次都总能检查出来不少。其实不管是菜鸟级还是资深级开发者都避免不了写出内存泄露的代码，规则大家都懂，可是天知道什么时候手一抖就少写了个release？</p>

<p>好在项目决定转成ARC了，下面将自己转换的过程和中间遇到的问题写出来和大家共享，希望能减少大家解决同类问题的时间。</p>

<h2>一、前言</h2>

<h4>项目简介</h4>

<p>需要转换的Objective-C文件数量：1000个左右。</p>

<p>开发工具：Xcode 6.0.1</p>

<h4>转换方式</h4>

<p>我使用的是Xcode本身提供的ARC转换功能。当然你也可以手动手动转换，那不属于本文范畴，而且其工作量绝对能让你崩溃。</p>

<h2>二、转换过程</h2>

<h4>代码备份</h4>

<p>在进行如此大规模的更改之前，一定要先进行代码备份：直接在本地将代码复制一份，或者记住更改前代码在VCS上的版本号。</p>

<h4>过滤无需转换的文件</h4>

<p>找出项目中引用的仍使用手动内存管理的第三方库，或者某些你不希望转换的文件，对其添加<code>-fno-objc-arc</code>标记。</p>

<p>Xcode自动转换工具只针对Objective-C对象，只会处理<code>Objective-C/Objective-C++</code>即后缀名为<code>.m/.mm</code>的两种文件，因此其他的<code>C/C++</code>对应的<code>.c/.cpp</code>都无需理会。</p>

<h4>执行检查操作</h4>

<p>使用Xcode转换工具入口如图所示：</p>

<p>refactor.png</p>

<p>点击<code>Convert to Objective-C ARC</code>后会进入检查操作入口，如图：</p>

<p>check.png</p>

<p>该步骤要选择哪些文件需要转换，如果前面将无需转换的文件都添加了<code>-fno-objc-arc</code>标记后，这里可以全选。</p>

<p>点击check按钮后Xcode会帮助我们检查代码中存在的不符合ARC使用规则的错误或警告，只有所有的错误都解决以后才能执行真正的转换操作。</p>

<h4>解决错误/告警</h4>

<p>执行完check操作后，会给出提示：</p>

<p>error.png</p>

<p>三百多个错误，同时还有一千两百多个警告信息，都要哭了。。。</p>

<p>错误和警告的解决内容较多，后面会单独介绍。</p>

<h4>执行转换操作</h4>

<p>解决完所有的error后，会弹出下述提示界面：</p>

<p>notice.png</p>

<p>大意是Xcode将要将你的工程转换成使用ARC管理内存，所有更改的代码在真正更改之前会在一个review界面展示。同时所有的更改完成以后，Xcode会讲项目Target对应的工程设置的使用ARC设置（<code>Objective-C Automatic Reference Counting</code>）会被置成YES（上图右上角的警告标识就是在告诉我们项目已经支持ARC了，但工程中有文件还不支持）：</p>

<p>use_arc.png</p>

<p>这时离成功就不远了，胜利在望！</p>

<p>点击next按钮后跳转到review界面，样式类似于使用Xcode提交SVN的确认提交界面，如下图所示：</p>

<p>review.png</p>

<p>该界面列出了所有需要有代码更改的文件，同时能够直接对比转换前和转换后的代码变化。为了稳妥起见，我选择了每个文件都点进去扫了一眼，这也给我们一次机会检查是否漏掉了不能转换的文件。确定一切无误以后，点击右下角的save按钮，一切就大功告成了！</p>

<h2>错误/警告解决</h2>

<h4>错误</h4>

<ul>
<li>ARC forbids synthesizing a property of an Objective-C object with unspecified ownership or storage attribute</li>
</ul>


<p>readonly_error.png</p>

<p>property属性必须指定一个内存管理关键字，在属性定义处增加strong关键字即可。</p>

<ul>
<li>ARC forbids explicit message send of &lsquo;release&rsquo;</li>
</ul>


<p>release_error.png</p>

<p>这种情况通常是使用包含release的宏定义，将该宏和使用该宏的地方删除即可。</p>

<ul>
<li>Init methods must return a type related to the receiver type</li>
</ul>


<p>init_return_type.png</p>

<p>错误原因是A类里的一个方法以init开头，而且返回的是B类型，好吧，乖乖改方法名。</p>

<ul>
<li>Cast of C pointer type &lsquo;ivPointer&rsquo; (aka &lsquo;void <em>&rsquo;) to Objective-C pointer type &lsquo;iFlyTTSManager_old </em>&rsquo; requires a bridged cast</li>
</ul>


<p>cast_pointer_objective-c.png</p>

<p>这是<code>Toll-Free Bridging</code>转换问题，在ARC下根据情况使用对应的转换关键字就行了，后文会专门介绍。</p>

<h4>警告</h4>

<p>解决警告的目的是消除警告处代码存在的隐患，既然Xcode给了提示，那么每一个警告信息都值得我们认真对待。</p>

<ul>
<li>Capturing <code>self</code> in this block is likely to lead to a retain cycle</li>
</ul>


<p>block_capturing_self.png</p>

<p>这是典型的block循环引用问题，将block中的self改成使用指向self的weak指针即可。</p>

<ul>
<li>Using &lsquo;initWithArray:&rsquo; with a literal is redundant</li>
</ul>


<p>literal_is_redundant.png</p>

<p>好吧，原来是没必要的alloc操作，直接按Xcode提示将alloc删除即可：</p>

<p>literal_is_redundant_fix.png</p>

<ul>
<li>Init methods must return a type related to the receiver type</li>
</ul>


<p>init_methods.png</p>

<p>原来是A类里的一个方法以init开头，而且返回的是B类型，好吧，乖乖改方法名。</p>

<ul>
<li>Property follows Cocoa naming convention for returning ‘owned’ objects</li>
</ul>


<p>property_follows.png</p>

<p>这是因为@property属性的命名以new开头了，可恶。。。修改方法是将对应的getter方法改成非new开头命名的：</p>

<p>property_follows_fix.png</p>

<p>ARC下方法名如果是以new/alloc/init等开头的，而且还不是类的初始化方法，就该小心了，要么报错，要么警告，原因你懂的。</p>

<ul>
<li>Block implicitly retains &lsquo;self&rsquo;; explicitly mention &lsquo;self&rsquo; to indicate this is intended behavior</li>
</ul>


<p>block_implicitly_retains.png</p>

<p>意思是block中使用了self的实例变量_selectedModeMarkerView，因此block会隐式的retain住self。Xcode认为这可能会给开发者造成困惑，或者因此而因袭循环引用，所以警告我们要显示的在block中使用self，以达到block显示retain住self的目的。</p>

<p>该警告有两种改法：
①按照Xcode提示，改成self->_selectedModeMarkerView：</p>

<p>block_implicitly_retains_fix1.png</p>

<p>②直接将该警告关闭
警告名称为：<code>Implicit retain of ‘self’ within blocks</code>
对应的Clang关键字是：<code>-Wimplicit-retain-self</code></p>

<p>block_implicitly_retains_fix2.png</p>

<ul>
<li>Weak property may be unpredictably set to nil 和 Weak property &lsquo;delegate&rsquo; is accessed multiple times in this method but may be unpredictably set to nil; assign to a strong variable to keep the object alive</li>
</ul>


<p>weak_property_unpredictably.png</p>

<p>这是工程中数目最多的警告，这是因为所有的delegate属性都是weak的，Xcode默认开启了下图中的两个警告设置，将其关闭即可：</p>

<p>weak_property_unpredictably_fix.png</p>

<ul>
<li>Capturing &lsquo;self&rsquo; strongly in this block is likely to lead to a retain cycle</li>
</ul>


<p>retain_cycle.png</p>

<p>这是明显的block导致循环引用内存泄露的情况，之前代码中坑啊！修改方案：</p>

<p>retain_cycle_fix.png</p>

<ul>
<li>Method parameter of type &lsquo;NSError <em>__autoreleasing </em>&rsquo; with no explicit ownership</li>
</ul>


<p>autorelease_error.png</p>

<p>这种就不用说了，按警告中的提示添加<code>__autoreleasing</code>关键字即可。</p>

<p>以上列出的错误和警告只是数量较多的，还有很多其他就不在这里一一列举了。</p>

<p>另外，推荐  <a href="https://twitter.com/mattt">Mattt Thompson</a> 大神关于Clang中几乎所有warning的名称和对应报错提示语的网站：<a href="http://fuckingclangwarnings.com/">http://fuckingclangwarnings.com/</a>，以后解决warning类问题就简单多了！</p>

<h2>Xcode自动转换</h2>

<h4>关键字转换</h4>

<p>Xcode会自动将某些关键字自动转换成ARC的对应版本。</p>

<ul>
<li>retain自动转成strong，如图：</li>
</ul>


<p>retain_strong.png</p>

<ul>
<li>assign关键字转成weak</li>
</ul>


<p>修饰Objective-C对象或者id类型对象的assign关键字会被转成weak，如图：</p>

<p>assign_weak.png</p>

<p>但是修饰Int/bool等数值型变量的assign不会自动转换成weak，如图：</p>

<p>assign_not_weak.png</p>

<h4>关键字删除</h4>

<p>和手动内存管理相关的几个关键字，比如：<code>release/retain/autorelease/super dealloc</code>等会被删除；</p>

<p>dealloc方法中如果除了release/super dealloc语句外，如果别的代码，dealloc方法会保留,如图：</p>

<p>retain_dealloc.png</p>

<p>如果没有整个方法都会被删除：</p>

<p>delete_dealloc.png</p>

<h4>关键字替换</h4>

<ul>
<li>在转换时<strong>block关键字会被自动替换成</strong>weak：</li>
</ul>


<p>block_weak.png</p>

<ul>
<li>@autoreleasepool</li>
</ul>


<p>NSAutoreleasePool不支持ARC，会被替换成@autoreleasepool：</p>

<p>autoreleasepool.png</p>

<h4>关于被宏注释代码</h4>

<ul>
<li>使用宏定义的对象释放代码</li>
</ul>


<p>宏定义如下所示：</p>

<p>```objective-c</p>

<h1>define RELEASE_SAFELY(__POINTER) { \</h1>

<p>[(<strong>POINTER) release]; (</strong>POINTER) = nil; }
```
在执行ARC转换检查操作时，Xcode会在使用该宏的地方报错：</p>

<p>release_error.png</p>

<p>将该宏和使用该宏的地方删除即可。</p>

<ul>
<li>被宏注释掉的代码，Xcode在转换时是不会处理的，如图：</li>
</ul>


<p>marco_arc.png</p>

<p>PS：这是相当坑的一点，因为你根本预料不到工程中使用了多少宏，注释掉了多少代码。当你执行完转换操作，以为就大功告成的时候，却在某天因为一个宏的开启遇到了一堆新的转ARC不彻底的问题。这种问题也没招，只能遇到一个改一个了。</p>

<h2>ARC和block</h2>

<p>不管是手动内存管理还是ARC，block循环引用导致的内存泄露都是一个令人头疼的问题。在MRC中，解决block循环引用只需要使用__block关键字，在ARC下解决与block的使用就略显复杂了：</p>

<h4>__block关键字</h4>

<ul>
<li>block内修改外部变量</li>
</ul>


<p>和手动内存管理一样，ARC如果在block中需要修改block之外定义的变量需要使用<code>__block</code>关键字修饰，比如：</p>

<p>```objective-c
__block NSString *name = @&ldquo;foggry&rdquo;;
self.expireCostLabel.completionBlock = ^(){</p>

<pre><code>name = @"wangzz";
</code></pre>

<p>};</p>

<p>```</p>

<p>上例中name变量需要在block中修改，因此必须使用__block关键字。</p>

<ul>
<li>__block在MRC和ARC中的区别</li>
</ul>


<p>在ARC下的block中使用__block关键字修饰的对象时，block会retain该对象；而在MRC下却不会retain。关于这点在官方文档<a href="https://developer.apple.com/library/ios/releasenotes/objectivec/rn-transitioningtoarc/introduction/introduction.html">Transitioning to ARC Release Notes</a>中有详细的描述：</p>

<p><code>
In manual reference counting mode, __block id x; has the effect of not retaining x.
In ARC mode, __block id x; defaults to retaining x (just like all other values).
</code></p>

<p>下面的代码不管在MRC还是ARC中<code>myController</code>对象都是有内存泄露的：</p>

<p><code>objective-c
MyViewController *myController = [[MyViewController alloc] init…];
// ...
myController.completionHandler =  ^(NSInteger result) {
   [myController dismissViewControllerAnimated:YES completion:nil];
};
</code></p>

<p>内存泄露问题在MRC中可以按如下方式更改：</p>

<p>```objective-c
MyViewController * __block myController = [[MyViewController alloc] init…];<br/>
// &hellip;<br/>
myController.completionHandler =  ^(NSInteger result) {</p>

<pre><code>[myController dismissViewControllerAnimated:YES completion:nil];  
</code></pre>

<p>};
```</p>

<p>然而在ARC中这么改就不行了。正如开始所说的那样，在ARC中<code>myController.completionHandler</code>的block会retain<code>myController</code>对象，使得内存泄露问题仍然存在！！</p>

<p>在ARC中该问题有两种解决方案，第一种：</p>

<p>```objective-c
MyViewController * __block myController = [[MyViewController alloc] init…];<br/>
// &hellip;<br/>
myController.completionHandler =  ^(NSInteger result) {</p>

<pre><code>[myController dismissViewControllerAnimated:YES completion:nil];  
myController = nil;  
</code></pre>

<p>};
```
该方法在block中使用完myController时，是它指向nil。没有strong类型的指针指向myController指向的对象时，对象会被释放掉。</p>

<p>第二种种解决方案，直接使用<strong>weak代替</strong>block关键字：</p>

<p>```objective-c
MyViewController *myController = [[MyViewController alloc] init…];<br/>
// &hellip;<br/>
MyViewController * __weak weakMyViewController = myController;<br/>
myController.completionHandler =  ^(NSInteger result) {</p>

<pre><code>[weakMyViewController dismissViewControllerAnimated:YES completion:nil];  
</code></pre>

<p>};
```
该方法直接避免了对block对myController对象的retain。</p>

<h4>存在循环引用关系</h4>

<p>如果self直接或者间接的对block存在强引用，在block中又需要使用self关键字，此时self和block就存在循环引用的关系。此时必须使用__weak关键字定义一个指针指向self，在block中使用该指针来引用self：</p>

<p>```objective-c
MessageListController * __weak weakSelf = self;
self.messageLogic.loadMoreBlock = ^(IcarMessage * theMessage) {</p>

<pre><code>[weakSelf.tableView setPullTableIsLoadingMore:YES];
</code></pre>

<p>};
```</p>

<p>需要说明的是，尽管上例中weakSelf指针对self只是弱引用，但是self对block却是强引用，self的生命周期一定是长于block的，因此不用担心在block中使用weakSelf指针时，其指向的self会被释放掉。</p>

<h4>不存在循环引用关系</h4>

<p>下面的例子：</p>

<p>```objective-c
MyViewController *myController = [[MyViewController alloc] init…];
// &hellip;
MyViewController * __weak weakMyController = myController;
myController.completionHandler =  ^(NSInteger result) {</p>

<pre><code>MyViewController *strongMyController = weakMyController;
if (strongMyController) {
    // ...
    [strongMyController dismissViewControllerAnimated:YES completion:nil];
    // ...
}
else {
    // Probably nothing...
}
</code></pre>

<p>};
```</p>

<p>如前面所说，<code>myController.completionHandler</code>的block中不能直接使用<code>myController</code>对象，会造成内存泄露，因此需要先用一个weak的指针指向<code>myController</code>对象，然后在block中使用该weak指针。但是为了确保在block执行的时候<code>myController</code>对象没有被释放掉，就在block一开始的地方定义了一个临时的strong类型的指针<code>strongMyController</code>指向weak指针<code>weakMyController</code>，其实最终的结果就是block中对<code>myController</code>对象强引用了。在block执行完被销毁的时候，<code>strongMyController</code>指针变量会被销毁，其最终指向的<code>myController</code>对象因此也会被销毁。这样在使用一个对象的时候做就保证了该对象是存在的，使用完了再放弃该对象的所有权。</p>

<h2>ARC和Toll-Free Bridging</h2>

<p>MRC下的<code>Toll-FreeBridging</code>不涉及内存管理的转移，Objective-C（后文简称OC）和Core Foundation（后文简称CF）各自管理各自的内存,相互之间可以直接交换使用，比如：</p>

<p><code>objective-c
NSLocale *gbNSLocale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_GB"];
CFLocaleRef gbCFLocale = (CFLocaleRef)gbNSLocale;
</code></p>

<p>而在ARC下,事情就会变得复杂一些。因为ARC能够管理OC对象的内存,却不能管理CF对象,CF对象依然需要我们手动管理内存。在CF和OC之间bridge对象的时候,问题就出现了,编译器不知道该如何处理这个同时有OC指针和CF指针指向的对象。这时候,需要使用<code>__bridge</code>, <code>__bridge_retained</code>, <code>__bridge_transfer</code>等修饰符来告诉编译器该如何去做。</p>

<ul>
<li>__bridge</li>
</ul>


<p>它告诉编译器仍然负责管理好在OC一端的引用计数的事情,开发者也继续负责管理好在CF一端的事情，比如：</p>

<p><code>objective-c
CFStringRef cfString = CFStringCreateWithCString(kCFAllocatorDefault, "CFString", kCFStringEncodingUTF8);
NSString *ocString = (__bridge NSString *)cfString;
CFRelease(cfString);
NSLog(@"%@",ocString);
</code></p>

<ul>
<li>__bridge_retained 或 CFBridgingRetain</li>
</ul>


<p>二者作用是一样的，只是用法不同。</p>

<p>告诉编译器需要retain对象,而开发者在CF一端负责释放。这样就算对象在OC一端被释放,只要开发者不释放CF一端的对象, 对象就不会被真的销毁。</p>

<p><code>objective-c
NSArray *ocArray = [[NSArray alloc] initWithObjects:@"foggry", nil];
CFArrayRef cfArray = (__bridge_retained CFArrayRef)ocArray;
/**
 使用cfArray
 **/
CFRelease(cfArray);
</code></p>

<ul>
<li>__bridge_transfer 或 CFBridgingRelease</li>
</ul>


<p>二者作用也是一样的，只是用法不同。</p>

<p>该关键字告诉编译器bridge的同时,也转移了对象的所有权，比如：</p>

<p><code>objective-c
CFStringRef cfString = CFStringCreateWithCString(kCFAllocatorDefault, "CFString", kCFStringEncodingUTF8);
NSString *ocString = (__bridge_transfer NSString *)cfString;
//CFRelease(cfString); //不再需要释放操作
NSLog(@"%@",ocString);
</code></p>

<p>转换过程中大家只需要根据具体需求选用适当的关键字即可。</p>

<p>另外，在ARC中<code>id</code>和<code>void *</code>也不能直接相互转换了，必须通过<code>Toll-FreeBridging</code>使用适当的关键字修饰。</p>

<h2>ARC和IBOutLet</h2>

<p>对于IBOutLet属性应该用strong还是weak一直都有疑惑。关于这一点<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW6">官方文档</a>是这么介绍的：</p>

<blockquote><blockquote><blockquote></blockquote></blockquote></blockquote>

<p>From a practical perspective, in iOS and OS X outlets should be defined as declared properties. Outlets should generally be weak, except for those from File’s Owner to top-level objects in a nib file (or, in iOS, a storyboard scene) which should be strong. Outlets that you create should therefore typically be weak, because:</p>

<p>Outlets that you create to subviews of a view controller’s view or a window controller’s window, for example, are arbitrary references between objects that do not imply ownership.
The strong outlets are frequently specified by framework classes (for example, UIViewController’s view outlet, or NSWindowController’s window outlet).</p>

<blockquote><blockquote><blockquote></blockquote></blockquote></blockquote>

<p>那么长的一段英文想说的是：</p>

<p>如果nib文件构建的view是直接被Controller引用的顶层view，对应的IBOutLet属性应该是strong；</p>

<p>如果view是顶层view上的一个子view，那么该view的属性应该是weak，因为顶层view被Controller使用strong属性引用了，而顶层view本身又持有该view；</p>

<p>如果Controller对某个view需要单独引用，或者Controller没有引用某个view的父view，那么其属性也应该是strong。</p>

<p>好吧，其实我能说如果你实在懒得区分什么时候用strong，什么时候用weak，那就将所以后的IBOutLet属性都设成strong吧！在Controller销毁的时候，对应的IBOutLet实例变量也会被销毁，strong指针会被置成nil，因此也不会有内存问题。</p>

<h2>参考文档</h2>

<ul>
<li><a href="https://developer.apple.com/library/ios/releasenotes/objectivec/rn-transitioningtoarc/introduction/introduction.html">Transitioning to ARC Release Notes</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW6">Managing the Lifetimes of Objects from Nib Files</a></li>
<li><a href="https://mikeash.com/pyblog/friday-qa-2012-04-13-nib-memory-management.html">Nib Memory Management</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iPhone屏幕知识点解析]]></title>
    <link href="http://wangzz.github.io/blog/2014/09/28/iphoneping-mu-zhi-shi-dian-jie-xi/"/>
    <updated>2014-09-28T14:34:37+08:00</updated>
    <id>http://wangzz.github.io/blog/2014/09/28/iphoneping-mu-zhi-shi-dian-jie-xi</id>
    <content type="html"><![CDATA[<p><img src="/images/article7/iphone5-6.jpg" alt="iphone5-6" /></p>

<h2>一、屏幕相关知识点</h2>

<h4>1、屏幕尺寸</h4>

<p>在显示器世界里，屏幕尺寸都是由屏幕对脚线长度表示的，单位是英寸。比如iPhone4的3.5寸屏就意味着屏幕对角线的长度是3.5英寸。</p>

<h4>2、分辨率</h4>

<p>分辨率是任何一款手机产品最重要的参数之一。显示屏是由一个个像素组成的，分辨率可以简单理解成屏幕像素的数目。比如iPhone4的屏幕分辨率为640×960，就表示屏幕的横向有640个像素点，纵向有960个像素点。</p>

<!-- more -->


<h4>3、PPI</h4>

<p>PPI（Pixels Per Inch）表示单位面积上的像素点数目。分辨率可以表示屏幕包含的像素数目，但要想描述屏幕的显示质量，还需要知道屏幕尺寸，最后算出单位面积上的像素点数目。显然PPI越高，屏幕显示效果越细腻。</p>

<p>PPI计算公式：</p>

<p><img src="/images/article7/PPI.jpg" alt="PPI" /></p>

<p>其中，X：长度像素数；Y：宽度像素数；Z：屏幕尺寸即对角线长度</p>

<h4>4、Points</h4>

<p>可以简单理解成我们使用<code>UIKit</code>或 <code>Core Animation</code>处理界面元素时所用到的逻辑坐标系统。Points是在iOS4以后引入的，出现的目的是提供一种与设备无关的一致的输出效果。</p>

<p>苹果考虑到以后有可能推出不同分辨率屏幕的手机，如果开发者在界面布局的时候操纵像素，就会导致每种不同分辨率的设备都要有一份适配代码。比如在分辨率为320×480的iPhone3GS上，要画一条长度1英寸的线条，假设需要50个像素，即线条的长度设成50像素；但是在分辨率为640×960的iPhone4上，50像素所能表示的实际长度只有iPhone3GS的一半，即0.5英寸。因此开发者必须使用两套适配代码：在iPhone3GS上将线条长度设成50像素，在iPhone4上设成100像素。这还仅仅是两款设备，如果算上后来的iPhone5/5C/5S和iPhone6/6+，每种分辨率都来一套适配代码，开发者岂不是得疯掉？？</p>

<p>现在苹果使用了一套逻辑坐标系统来解决多分辨率屏幕适配问题，将屏幕上的每一个点都用以屏幕左上角为原点，横向为X轴，纵向为Y轴的坐标来表示（PS：并不是所有的框架默认坐标系统都是这样，比如<code>APPKit</code>中的<code>NSView</code>；当然开发者也可以将<code>UIKit</code>和 <code>Core Animation</code>的坐标系统改成以屏幕左下角为原点，但原理都是一样的。）。以iPhone3GS/4为例，他们的坐标系统中X和Y的最大值都分别是320和480。</p>

<p>有了逻辑坐标系统，想在分辨率不同的iPhone3GS/4画一条长度均为1英寸的线条就变成了这样：将线的长度设成50Points（假设1英寸对应那么多个Points），<code>UIKit</code>在屏幕上绘图的时候会判断屏幕分辨率，如果是iPhone3GS的320×480分辨率屏幕，会自动使用50像素绘制；如果是iPhone4的640×960分辨率，会自动使用100像素绘制。</p>

<p>这种机制使得在4寸屏幕的iPhone5出来之前，iOS开发者在设备屏幕适配上的工作量几乎为零（当然，需要准备两套图片），对此Android同行们早就口水直下三千尺了。后来随着iPhone屏幕尺寸的变化，逻辑坐标系统的取值范围也发生了变化，这才让iOS开发者有点事情可做。</p>

<h4>5、渲染比例（Scale）</h4>

<p>像素点数目和逻辑坐标点数目的比值，就是渲染比例（Scale）。更直观的说法是一个逻辑坐标点，需要用几个像素点来渲染。</p>

<p>iPhone3GS的逻辑坐标系统是320×480，分辨率是320×480，即每个坐标点对应一个像素，即Scale为1；iPhone4的逻辑坐标系统是320×480，分辨率是640×960，每个坐标点对应两个像素点，即Scale为2。</p>

<p>因此，为了适配iPhone6+的屏幕，以后又得曾加一份@3x分辨率的图片了。</p>

<h4>6、宽高比</h4>

<p>屏幕宽度和高度的比例，也可以是分辨率的横向像素点数目和纵向像素点数目的比例，他们通常是一致的，一般用整数表示。</p>

<p>iPhone3GS/4/4S的宽高比2:3，iPhone5/5C/5S/6/6+的宽高比都是9:16。</p>

<p>当年iPhone5出来的时候，适配3.5寸屏幕的应用上下黑边的场景仍记忆犹新，用户体验很不好，虽然大部分应用都迅速的做了适配。还好苹果这次学聪明了，从4寸屏升级到iPhone6的4.7寸屏和iPhone6+的5.5寸屏，宽高比并没有变化。也就是说原来在iPhone5上运行的应用能够通过拉伸平滑过渡到iPhone6/6+上，可能会稍微有点模糊。不过比起3.5寸到4寸屏的升级来说已经好很多了。</p>

<h2>二、说明</h2>

<h4>1、历代iPhone屏幕参数</h4>

<p>下面的一张图介绍了从iPhone4到iPhone6+的几代iPhone跟屏幕相关的几个关键参数：</p>

<p><img src="/images/article7/iPhone_display.png" alt="iPhone_display" /></p>

<p>需要说明的是，iPhone6+的逻辑坐标是414×736，渲染比例是3倍，因此对应的屏幕分辨率是1242×2208。但iPhone6+的实际屏幕分辨率是1080×1920，这时系统会把整体的显示内容做一个从新采样缩放，downsampling比例为1/1.15。</p>

<h4>2、老工程中的坐标系统</h4>

<p>使用Xcode6之前版本的Xcode创建的工程，在iPhone6/6+上运行，得到的逻辑坐标都是和iPhone5/5C/5S屏幕相同的320*568。这样就做到从4寸到4.7寸和5.5寸屏幕的无缝升级，即使我们什么都不做，我们的老工程也能在iPhone6/6+上几乎完美的运行。当然因为等比例放大了，图片可能会有模糊或锯齿感。</p>

<p>要想让老工程的坐标系统恢复正常，可以通过为Target添加<code>LaunchImage</code>或者<code>Launch Screen File</code>来实现，如下图所示：</p>

<p><img src="/images/article7/LaunchFile.png" alt="LaunchFile" /></p>

<p><code>LaunchImage</code>的方式需要在<code>Images.xcassets</code>里，删除旧的<code>LaunchImage</code>组，然后新建<code>LaunchImage</code>组，添加对应高分辨率的图片。对此，这里有一篇更详细的图文介绍：<a href="http://matthewpalmer.net/blog/2014/09/10/iphone-6-plus-launch-image-adaptive-mode/">How to Add a Launch Image for the iPhone 6</a>。</p>

<p>其中<code>Launch Screen File</code>是Xcode6和iOS8新加的功能，它用一个xib文件来作为启动画面。App在旧版iOS启动时，该属性会被自动忽略，不会造成异常。</p>

<p>上面两种设置，只要启用任意一个即可让App进入高分辨率模式。鉴于现在不少App还需要兼容iOS5，而第一种方法在iOS5上可能有<a href="http://stackoverflow.com/questions/19220082/support-of-ios-5-0-icons-with-xcode-5">bug</a>，所以这里推荐用第二种方法。</p>

<h2>三、参考文档</h2>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingios/GraphicsDrawingOverview/GraphicsDrawingOverview.html">Drawing and Printing Guide for iOS</a></li>
<li><a href="http://baike.baidu.com/view/7687.htm">分辨率</a></li>
<li><a href="http://blog.ibireme.com/2014/09/16/adapted_to_iphone6/#rd?sukey=f3735aed1ca7f2658e86e2e18cb36d80fed889a7bdfd2d651a1aaef8f9941b691c71e4e8353e61cd57237e4cd0b3edc6#jtss-tsina">大屏iPhone的适配</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreAnimation系列之基础变换]]></title>
    <link href="http://wangzz.github.io/blog/2014/08/27/coreanimationxi-lie-zhi-ji-chu-bian-huan/"/>
    <updated>2014-08-27T12:21:50+08:00</updated>
    <id>http://wangzz.github.io/blog/2014/08/27/coreanimationxi-lie-zhi-ji-chu-bian-huan</id>
    <content type="html"><![CDATA[<p>从<a href="http://blog.csdn.net/wzzvictory">CSDN</a>时代开始，就有用一系列文章聊聊CoreAnimation的打算，这算是本系列中的第三篇了。一直以来都是哪天心情好的时候来一篇，真怀疑等把整个系列写完的时候CoreAnimation是不是都要被Apple换掉了。</p>

<p>本文打算介绍自己对基础变换的认识。</p>

<h2>一、基础变换与数学</h2>

<h4>1.两种坐标系</h4>

<p>不管是平面几何还是立体几何，笛卡尔坐标系都是我们学习和研究几何的最基础工具。的笛卡尔坐标系主要分两种：左手坐标系和右手坐标系。</p>

<p>对于三维坐标系，<a href="http://baike.baidu.com/view/2939423.htm">百度百科</a>上给出了右手坐标系的判断方法：在空间直角坐标系中，让右手拇指指向x轴的正方向，食指指向y轴的正方向，如果中指能指向z轴的正方向，则称这个坐标系为右手直角坐标系。同理左手直角三维坐标系。</p>

<!-- more -->


<p>下图直观的表示了上述判断方法（图片来自<a href="http://outofmemory.cn/wr/?u=http%3A%2F%2Fwonderffee.github.io%2Fblog%2F2013%2F10%2F17%2Fa-simple-method-to-determine-positive-rotation-in-in-three-dimensional-space%2F">这里</a>）：</p>

<p><img src="/images/article6/coordinate-system.jpg" alt="left-right hand coordinate" /></p>

<p>由此判断，从中学到大学的课堂上我们接触的立体几何都是右手系。</p>

<h4>2.基础变换的数学公式</h4>

<p>一个点在立体空间内的变换可以通过数学公式表示，前面讲那么多左手和右手坐标系相关的内容是因为<code>不同坐标系下计算公式不同</code>。</p>

<p>iOS中CoreAnimation的CALayer默认使用的是<code>左手坐标系</code>（使用哪种坐标系可以通过CALayer的<code>geometryFlipped</code>属性更改，该值默认为NO，设为YES时表示使用右手坐标系），因此本文后面所说的所有坐标系都是之左手坐标系。</p>

<p>变换对于动画来说应该是最基础最核心的内容了，CoreAnimation中基础变换包括平移（Translate）、缩放（Scale）、旋转（Rotate）三种。假如三维空间中有一个点(x0, y0, z0)，该点经过一定条件的基础变换，变换后的坐标为(x, y, z)，则针对平移、缩放、旋转三种基础变换，对应的坐标变换关系如下：</p>

<h6>2.1 平移</h6>

<p>平移对应的变化量为(δx, δy, δz)。</p>

<p><code>
x = x0 + δx;
y = y0 + δy;
z = z0 + δz;
</code></p>

<h6>2.2 缩放</h6>

<p>缩放对应的缩放倍数为(δx, δy, δz)。</p>

<p><code>
x = x0 * δx;
y = y0 * δy;
z = z0 * δz;
</code></p>

<h6>2.3 旋转</h6>

<p>旋转的方式有很多，比如简单点的绕X轴、Y轴、Z轴旋转，复杂点的还有绕任意三维向量旋转。为了简单起见，旋转以绕Z轴旋转了角度α（注意这里及后文所有涉及角度的地方都是弧度制）为例，对应的变化关系为：</p>

<p><code>
x = y0*sinα + x0*cosα;
y = y0*conα - x0*sinα;
z = z0;
</code></p>

<p>其它的大家感兴趣可以自己推倒下。</p>

<h2>二、变换矩阵</h2>

<p>在CoreAnimation中用CATransform3D来表示三维齐次坐标变换矩阵，在齐次坐标中n维空间的坐标需要用n+1个元素的坐标元组来表示（详情还请自行Google），因此CATransform3D定义如下：</p>

<p><code>
struct CATransform3D
{
  CGFloat m11, m12, m13, m14;
  CGFloat m21, m22, m23, m24;
  CGFloat m31, m32, m33, m34;
  CGFloat m41, m42, m43, m44;
};
</code>
为什么实现变换要有变换矩阵呢？</p>

<p>以上文中旋转的计算公式为例，可以使用如下矩阵运算表示：</p>

<p><img src="/images/article6/matrix1.png" alt="left-right hand coordinate" /></p>

<p>其中的矩阵：</p>

<p><img src="/images/article6/matrix2.png" alt="left-right hand coordinate" /></p>

<p>就被称为点(x0, y0, z0)绕Z轴旋转角度α的变换矩阵。</p>

<p>由于放射变换可以通过矩阵变换来实现，而且看起来更加直观，因此变换公式通常都用对应的变换矩阵表示。</p>

<p>在CoreAnimation中平移、缩放、旋转对应的变换矩阵为：</p>

<h4>1. 平移</h4>

<p><img src="/images/article6/matrix3.png" alt="left-right hand coordinate" /></p>

<p>其中δx、δy、δz表示三个坐标上对应的平移量。</p>

<h4>2. 缩放</h4>

<p><img src="/images/article6/matrix4.png" alt="left-right hand coordinate" /></p>

<p>其中δx、δy、δz表示三个坐标上对应的缩放倍数。</p>

<h4>3. 旋转</h4>

<p><img src="/images/article6/matrix5.png" alt="left-right hand coordinate" /></p>

<p>该矩阵为任意点(x, y, z)绕任意向量旋转旋转角度α的旋转向量。</p>

<h2>三、验证</h2>

<p>前面总结了CoreAnimation中三种基础变换对应的变换矩阵，这样以来我们就能自己对任意的矩阵做变换了。平移、缩放、旋转对应的变换矩阵计算方法如下：</p>

<h4>1. 平移</h4>

<p>```objective-c
&ndash; (CATransform3D)translateWithMatrix:(CATransform3D)t x:(CGFloat)x y:(CGFloat)y z:(CGFloat)z
{</p>

<pre><code>CATransform3D matrixTransform = CATransform3DIdentity;
matrixTransform.m41 = x;
matrixTransform.m42 = y;
matrixTransform.m43 = z;

return CATransform3DConcat(matrixTransform, t);
</code></pre>

<p>}
```</p>

<p>该方法根据平移变换矩阵的计算方式，得到平移参数(x, y, z)对应的变换矩阵，然后和原始矩阵相乘，得到最终的变换矩阵。</p>

<h4>2. 缩放</h4>

<p>```objective-c
&ndash; (CATransform3D)scaleWithMatrix:(CATransform3D)t x:(CGFloat)x y:(CGFloat)y z:(CGFloat)z
{</p>

<pre><code>CATransform3D matrixTransform = CATransform3DIdentity;
matrixTransform.m11 = x;
matrixTransform.m22 = y;
matrixTransform.m33 = z;

return CATransform3DConcat(matrixTransform, t);
</code></pre>

<p>}
```</p>

<p>该方法根据缩放变换矩阵的计算方式，得到缩放参数(x, y, z)对应的变换矩阵，然后和原始矩阵相乘，得到最终的变换矩阵。</p>

<h4>3. 旋转</h4>

<p>```objective-c
&ndash; (CATransform3D)rotateWithMatrix:(CATransform3D)t angle:(CGFloat)angle x:(CGFloat)x y:(CGFloat)y z:(CGFloat)z
{</p>

<pre><code>CGFloat unitValue = sqrtf(powf(x, 2)+powf(y, 2)+powf(z, 2));
CGFloat x0 = x/unitValue;
CGFloat y0 = y/unitValue;
CGFloat z0 = z/unitValue;

CATransform3D matrixTransform = CATransform3DIdentity;
matrixTransform.m11 = powf(x0, 2)*(1-cosf(angle))+cosf(angle);
matrixTransform.m12 = x0*y0*(1-cosf(angle))+z0*sinf(angle);
matrixTransform.m13 = x0*z0*(1-cosf(angle))-y0*sinf(angle);

matrixTransform.m21 = x0*y0*(1-cosf(angle))-z0*sinf(angle);
matrixTransform.m22 = powf(y0, 2)*(1-cosf(angle))+cosf(angle);
matrixTransform.m23 = y0*z0*(1-cosf(angle))+x0*sinf(angle);

matrixTransform.m31 = x0*z0*(1-cosf(angle))+y0*sinf(angle);
matrixTransform.m32 = y0*z0*(1-cosf(angle))-x0*sinf(angle);
matrixTransform.m33 = powf(z0, 2)*(1-cosf(angle))+cosf(angle);

return CATransform3DConcat(matrixTransform, t);
</code></pre>

<p>}
```</p>

<p>该方法根据旋转变换矩阵的计算方式，得到旋转参数(angle, x, y, z)对应的变换矩阵，然后和原始矩阵相乘，得到最终的变换矩阵。</p>

<h4>4. demo</h4>

<p>以旋转变换demo为例：</p>

<p>```objective-c
&ndash; (void)logTransform:(CATransform3D)t
{</p>

<pre><code>NSLog(@"***************************");
NSLog(@"%f,%f,%f,%f",t.m11,t.m12,t.m13,t.m14);
NSLog(@"%f,%f,%f,%f",t.m21,t.m22,t.m23,t.m24);
NSLog(@"%f,%f,%f,%f",t.m31,t.m32,t.m33,t.m34);
NSLog(@"%f,%f,%f,%f",t.m41,t.m42,t.m43,t.m44);
</code></pre>

<p>}</p>

<ul>
<li><p>(IBAction)onRotateButtonAction:(id)sender
{
  //Rotate</p>

<p>  //随意的原始矩阵
  CATransform3D matrixOrigin = CATransform3DMakeRotation(1, 4, 3, 6);</p>

<p>  CGFloat x = 2, y = 3, z = 4; //旋转向量（2,3,4）
  CGFloat angle = 30.0f * M_PI / 180.0f; //旋转角度30°，计算对应的弧度</p>

<p>  //通过系统函数计算变换矩阵
  CATransform3D matrixSystem = CATransform3DRotate(matrixOrigin, angle, x, y, z);
  systemLayer.transform = matrixSystem;
  [self logTransform:matrixSystem];</p>

<p>  //自定义方法计算3D旋转矩阵
  CATransform3D matrixCalculate = [self rotateWithMatrix:matrixOrigin angle:angle x:x y:y z:z];
  customLayer.transform = matrixCalculate;
  [self logTransform:matrixCalculate];
}
```</p></li>
</ul>


<p>demo使用随意生成的参数<code>matrixOrigin</code>模拟一个CALayer的初始<code>transform</code>属性值，然后使用同一组变换参数，分别通过系统函数和自定义方法对原始<code>transform</code>做变换，然后对比变换结果。最终的计算得到的变换矩阵可以通过log的方式打印出来，也可以在界面上做直观的展示。</p>

<p>平移和缩放变换矩阵的验证方式和旋转类似。</p>

<p>经过对比发现两种计算方式得到的最终变换矩阵是完全相同的，这进一步验证了CoreAnimation中变换矩阵的计算方式。</p>

<p>完整的<a href="https://github.com/wangzz/Demo/tree/master/CoreAnimationDemo">demo</a>放到了github上，欢迎大家下载。</p>

<h2>四、说明</h2>

<ul>
<li>变换矩阵可以组合</li>
</ul>


<p>可以同时对CALayer进行多种变换，比如同时缩放和旋转，直接通过矩阵相乘得到组合变换的变换矩阵。CoreAnimation提供了变换矩阵组合的方法：</p>

<p><code>objective-c
CATransform3D CATransform3DConcat (CATransform3D a, CATransform3D b)
</code>
需要注意的是，通常情况下矩阵乘法不支持交换律，因此两个矩阵a、b的顺序不能交换。</p>

<ul>
<li>最好不要手动修改变换矩阵的值</li>
</ul>


<p>CoreAnimation的3D变换对应的4维变换矩阵，单独修改其中的任何一个值都可能带来不可控的变换结果，因此不建议单独手动修改变换矩阵，而是通过基础变换或者基础变换组合的方式修改。</p>

<ul>
<li>理解有误的地方还望大家指出。</li>
</ul>


<h2>五、参考文档</h2>

<ul>
<li><a href="http://www.thinkandbuild.it/introduction-to-3d-drawing-in-core-animation-part-2/">INTRODUCTION TO 3D DRAWING IN CORE ANIMATION</a></li>
<li><a href="http://en.wikipedia.org/wiki/Rotation_matrix">Rotation matrix</a></li>
<li><a href="http://baike.baidu.com/view/2939423.htm">右手坐标系</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS屏幕旋转学习笔记]]></title>
    <link href="http://wangzz.github.io/blog/2014/08/08/ping-mu-xuan-zhuan-xue-xi-bi-ji/"/>
    <updated>2014-08-08T09:39:04+08:00</updated>
    <id>http://wangzz.github.io/blog/2014/08/08/ping-mu-xuan-zhuan-xue-xi-bi-ji</id>
    <content type="html"><![CDATA[<h2>一、两种orientation</h2>

<p>了解屏幕旋转首先需要区分两种orientation</p>

<h4>1、device orientation</h4>

<p>设备的物理方向</p>

<h4>2、interface orientation</h4>

<p>界面显示的方向</p>

<p>iOS提供了在设备旋转时，界面显示发生相应适配的能力，已达到方便用户使用并提供最佳显示效果的目的。开发者需要指定应用支持的显示方向，并对界面显示做出对应的适配。由于界面适配的工作量相当大，目前国内的应用大都只支持默认的竖屏方向，</p>

<!-- more -->


<h2>二、相关枚举定义</h2>

<h4>1、iOS5和之前版本（后文均简称iOS5）：</h4>

<p>```
typedef NS_ENUM(NSInteger, UIInterfaceOrientation) {</p>

<pre><code>UIInterfaceOrientationPortrait           = UIDeviceOrientationPortrait,
UIInterfaceOrientationPortraitUpsideDown = UIDeviceOrientationPortraitUpsideDown,
UIInterfaceOrientationLandscapeLeft      = UIDeviceOrientationLandscapeRight,
UIInterfaceOrientationLandscapeRight     = UIDeviceOrientationLandscapeLeft
</code></pre>

<p>};
```</p>

<h4>2、iOS6和之后版本（后文均简称iOS6）又新增了：</h4>

<p>```
typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) {</p>

<pre><code>UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait),
UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft),
UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight),
UIInterfaceOrientationMaskPortraitUpsideDown = (1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown),
UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),
UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown),
UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),
</code></pre>

<p>};
```</p>

<p>iOS6使用<code>NS_OPTIONS</code>的方式重新定义了UIInterfaceOrientationMaskPortrait、UIInterfaceOrientationMaskLandscapeLeft、UIInterfaceOrientationMaskLandscapeRight、UIInterfaceOrientationMaskPortraitUpsideDown几种基础枚举，这就意味着能以组合的方式更加方便的使用这些枚举值。</p>

<h2>三、相关方法</h2>

<h4>1、iOS5中控制屏幕旋转的方法：</h4>

<p><code>
// Applications should use supportedInterfaceOrientations and/or shouldAutorotate..
- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation NS_DEPRECATED_IOS(2_0, 6_0);
</code>
如果打算支持toInterfaceOrientation对应的方向就返回YES，否则返回NO。</p>

<h4>2、iOS6中控制屏幕旋转相关方法：</h4>

<p>```
// New Autorotation support.
&ndash; (BOOL)shouldAutorotate NS_AVAILABLE_IOS(6_0);
&ndash; (NSUInteger)supportedInterfaceOrientations NS_AVAILABLE_IOS(6_0);
// Returns interface orientation masks.
&ndash; (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation NS_AVAILABLE_IOS(6_0);</p>

<p>```</p>

<p>第一个方法决定是否支持多方向旋转屏，如果返回NO则后面的两个方法都不会再被调用，而且只会支持默认的UIInterfaceOrientationMaskPortrait方向；</p>

<p>第二个方法直接返回支持的旋转方向，该方法在iPad上的默认返回值是<code>UIInterfaceOrientationMaskAll</code>，iPhone上的默认返回值是<code>UIInterfaceOrientationMaskAllButUpsideDown</code>，详情见<a href="https://developer.apple.com/library/ios/qa/qa1688/_index.html">官方Q&amp;A文档</a>；</p>

<p>第三个方法返回最优先显示的屏幕方向，比如同时支持Portrait和Landscape方向，但想优先显示Landscape方向，那软件启动的时候就会先显示Landscape，在手机切换旋转方向的时候仍然可以在Portrait和Landscape之间切换；</p>

<h4>3、attemptRotationToDeviceOrientation方法</h4>

<p>从iOS5开始有了这个新方法：</p>

<p><code>
// call this method when your return value from shouldAutorotateToInterfaceOrientation: changes
// if the current interface orientation does not match the current device orientation, a rotation may occur provided all relevant view controllers now return YES from shouldAutorotateToInterfaceOrientation:
+ (void)attemptRotationToDeviceOrientation NS_AVAILABLE_IOS(5_0);
</code></p>

<p>该方法的使用场景是interface orientation和device orientation不一致，但希望通过重新指定interface orientation的值，立即实现二者一致；如果这时只是更改了支持的interface orientation的值，没有调用attemptRotationToDeviceOrientation，那么下次device orientation变化的时候才会实现二者一致，关键点在于能不能立即实现。</p>

<p>举个例子：</p>

<p>假设当前的interface orientation只支持Portrait，如果device orientation变成Landscape，那么interface orientation仍然显示Portrait；</p>

<p>如果这时我们希望interface orientation也变成和device orientation一致的Landscape，以iOS6为例，需要先将supportedInterfaceOrientations的返回值改成Landscape，然后调用attemptRotationToDeviceOrientation方法，系统会重新询问支持的interface orientation，已达到立即更改当前interface orientation的目的。</p>

<h2>四、如何决定interface orientation</h2>

<h4>1、全局控制</h4>

<p>Info.plist文件中，有一个<code>Supported interface orientations</code>，可以配置整个应用的屏幕方向，此处为全局控制。</p>

<h4>2、UIWindow</h4>

<p>iOS6的UIApplicationDelegate提供了下述方法，能够指定 UIWindow 中的界面的屏幕方向：</p>

<p><code>
- (NSUInteger)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window  NS_AVAILABLE_IOS(6_0);
</code>
该方法默认值为Info.plist中配置的<code>Supported interface orientations</code>项的值。</p>

<p>iOS中通常只有一个window，所以此处的控制也可以视为全局控制。</p>

<h4>3、controller</h4>

<p>只有以下两种情况：</p>

<ul>
<li>当前controller是window的rootViewController</li>
<li>当前controller是modal模式的</li>
</ul>


<p>时，orientations相关方法才会起作用（才会被调用），当前controller及其所有的childViewController都在此作用范围内。</p>

<h4>4、最终支持的屏幕方向</h4>

<p>前面所述的3种控制规则的交集就是一个controller的最终支持的方向；</p>

<p>如果最终的交集为空，在iOS6以后会抛出<code>UIApplicationInvalidInterfaceOrientationException</code>崩溃异常。</p>

<h2>四、强制屏幕旋转</h2>

<p>如果interface和device方向不一样，想强制将interface旋转成device的方向，可以通过attemptRotationToDeviceOrientation实现，但是如果想将interface强制旋转成任一指定方向，该方式就无能为力了。</p>

<p>不过聪明的开发者们总能想到解决方式：</p>

<h4>1、私有方法</h4>

<p><code>
[[UIDevice currentDevice] setOrientation:UIInterfaceOrientationPortrait];
</code>
但是现在苹果已经将该方法私有化了，越狱开发的同学可以试试。</p>

<h4>2、旋转view的transform</h4>

<p>也可以通过旋转view的transform属性达到强制旋转屏幕方向的目的，但个人感觉这不是靠谱的思路，可能会带来某些诡异的问题。</p>

<h4>3、主动触发orientation机制</h4>

<p>要是能主动触发系统的orientation机制，调用orientation相关方法，使新设置的orientation值起作用就好了。这样只要提前设置好想要支持的orientation，然后主动触发orientation机制，便能实现将interface orientation旋转至任意方向的目的。</p>

<p>万能的<a href="http://stackoverflow.com/a/14445888/2293677">stackoverflow</a>上提供了一种主动触发的方式：</p>

<p>在iOS4和iOS6以后：</p>

<p><code>
UIViewController *vc = [[UIViewController alloc]init];
[self presentModalViewController:vc animated:NO];
[self dismissModalViewControllerAnimated:NO];
[vc release];
</code></p>

<p>iOS5中：</p>

<p><code>
UIWindow *window = [[UIApplication sharedApplication] keyWindow];
UIView *view = [window.subviews objectAtIndex:0];
[view removeFromSuperview];
[window addSubview:view];
</code>
这种方式会触发UIKit重新调用controller的orientation相关方法，以达到在device方向不变的情况下改变interface方向的目的。</p>

<p>虽然不优雅，但却能解决问题，凑合吧。。</p>

<p>PS：</p>

<p>话说iOS8中的屏幕旋转相关方法又变化了，表示适配起来很蛋疼。。。</p>

<h2>五、参考文档</h2>

<ul>
<li><a href="https://developer.apple.com/library/ios/qa/qa1688/_index.html">Why won&rsquo;t my UIViewController rotate with the device?</a>；</li>
<li><a href="http://stackoverflow.com/a/14445888/2293677">How to force a UIViewController to Portait orientation in iOS 6</a></li>
<li><a href="http://www.cnblogs.com/jhzhu/p/3480885.html">IOS Orientation, 想怎么转就怎么转</a></li>
<li><a href="http://zhenby.com/blog/2013/08/20/talk-ios-orientation/">iOS 屏幕方向那点事儿</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS进程间通信之CFMessagePort]]></title>
    <link href="http://wangzz.github.io/blog/2014/06/04/iosjin-cheng-jian-tong-xin-zhi-cfmessageport/"/>
    <updated>2014-06-04T18:31:51+08:00</updated>
    <id>http://wangzz.github.io/blog/2014/06/04/iosjin-cheng-jian-tong-xin-zhi-cfmessageport</id>
    <content type="html"><![CDATA[<p>iOS系统是出了名的封闭，每个应用的活动范围被严格地限制在各自的沙盒中。尽管如此，iOS还是提供了若干进程间通信机制，CFMessagePort就是其中之一。</p>

<p>从类名可以看出，CFMessagePort属于<code>Core Foundation</code>层的东西，其实现部分是开源的，代码在可以在苹果的<a href="http://opensource.apple.com/source/CF/CF-855.14/CFMessagePort.c">开源代码库</a>中找到。</p>

<h2>使用方式</h2>

<h4>1、消息接收者</h4>

<p>CFMessagePort端口消息的接收者需要实现以下功能：</p>

<h6>1.1 注册监听</h6>

<p>消息接收者需要通过以下方式注册消息监听：</p>

<p>```objective-c
&ndash;(void)startListenning
{</p>

<pre><code>if (0 != mMsgPortListenner &amp;&amp; CFMessagePortIsValid(mMsgPortListenner))
{
    CFMessagePortInvalidate(mMsgPortListenner);
}
mMsgPortListenner = CFMessagePortCreateLocal(kCFAllocatorDefault,CFSTR(LOCAL_MACH_PORT_NAME),onRecvMessageCallBack, NULL, NULL);
CFRunLoopSourceRef source = CFMessagePortCreateRunLoopSource(kCFAllocatorDefault, mMsgPortListenner, 0);
CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopCommonModes);
NSLog(@"start listenning");
</code></pre>

<p>}
```</p>

<p> <!-- more --></p>

<p>其中<code>LOCAL_MACH_PORT_NAME</code>的定义为：</p>

<p>```objective-c</p>

<h1>define LOCAL_MACH_PORT_NAME    &ldquo;com.wangzz.demo&rdquo;</h1>

<p>```</p>

<p>经过查看源码发现，CFMessagePort实际上是通过mach port实现的。Mach port是iOS系统提供的基于端口的输入源，可用于线程或进程间通讯。而Runloop支持的输入源类型中就包括基于端口的输入源，因此可以使用Runloop做为CFMessagePort端口源事件的监听者。</p>

<p>上述代码有几点需要说明：</p>

<ul>
<li><p>通过CFMessagePortCreateLocal可以创建一个本地CFMessagePortRef对象</p></li>
<li><p>CFMessagePort对象是靠一个字符串来唯一标识的，这一点非常重要，在这里字符串是由宏<code>LOCAL_MACH_PORT_NAME</code>定义的；</p></li>
<li><p>创建CFMessagePort对象的同时设置了端口源事件的回调函数onRecvMessageCallBack，用于处理端口源事件；</p></li>
<li><p>将创建的对象作为输入源添加到Runloop中，从而实现对端口源事件的监听，当Runloop收到对应的端口源事件时，会调用上一步中指定的回调芳芳；</p></li>
</ul>


<h6>1.2 实现回调方法</h6>

<p>回调函数为CFMessagePortCallBack类型，其定义部分为：
<code>objective-c
typedef CFDataRef (*CFMessagePortCallBack) (
   CFMessagePortRef local,
   SInt32 msgid,
   CFDataRef data,
   void *info
);
</code>
各个参数的含义为：</p>

<ul>
<li><p>CFMessagePortRef local</p>

<p>  当前接收消息的CFMessagePortRef对象。</p></li>
<li><p>SInt32 msgid</p>

<p>  这个字段非常有用，用于标识消息。如果通信双方进程约定号每个msgid对应的数据结构，即可实现较为复杂的通信。</p></li>
<li><p>CFDataRef data</p>

<p>  通信的真正数据部分。</p></li>
<li><p>void *info</p>

<p>  为使用CFMessagePortCreateLocal方法创建port端口时指定的CFMessagePortContext对象的info字段，通常为空。</p></li>
</ul>


<p>该回调方法可以返回一个CFDataRef类型的数据给port消息的发送者，以实现有效的双方通信，这一点也非常重要。</p>

<p>我的回调函数onRecvMessageCallBack的实现：</p>

<p>```objective-c
CFDataRef onRecvMessageCallBack(CFMessagePortRef local,SInt32 msgid,CFDataRef cfData, void*info)
{</p>

<pre><code>NSLog(@"onRecvMessageCallBack is called");
NSString *strData = nil;
if (cfData)
{
    const UInt8  * recvedMsg = CFDataGetBytePtr(cfData);
    strData = [NSString stringWithCString:(char *)recvedMsg encoding:NSUTF8StringEncoding];
    /**

     实现数据解析操作

     **/

    NSLog(@"receive message:%@",strData);
}

//为了测试，生成返回数据
NSString *returnString = [NSString stringWithFormat:@"i have receive:%@",strData];
const char* cStr = [returnString UTF8String];
NSUInteger ulen = [returnString lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
CFDataRef sgReturn = CFDataCreate(NULL, (UInt8 *)cStr, ulen);

return sgReturn;
</code></pre>

<p>}
```</p>

<p>该方法实现的较为简单，解析约定的数据（测试代码中约定传送的是string）,为了测试，同时生成一个CFDataRef数据返回给port消息的发送者。</p>

<h6>1.3 取消端口监听</h6>

<p>可以通过如下方式取消对port端口的监听：</p>

<p>```objective-c
&ndash; (void)endLisenning
{</p>

<pre><code>CFMessagePortInvalidate(mMsgPortListenner);
CFRelease(mMsgPortListenner);
</code></pre>

<p>}
```
CFMessagePortInvalidate会停止port消息的发送和接收操作，而只有调用了CFRelease，CFMessagePortRef对象才真正的被释放掉。</p>

<h4>2、消息发送者</h4>

<p>发送部分代码如下：</p>

<p>```objective-c
&ndash;(NSString *)sendMessageToDameonWith:(id)msgInfo msgID:(NSInteger)msgid
{</p>

<pre><code>// 生成Remote port
CFMessagePortRef bRemote = CFMessagePortCreateRemote(kCFAllocatorDefault, CFSTR(MACH_PORT_REMOTE));
if (nil == bRemote) {
    NSLog(@"bRemote create failed");
    return nil;
}

// 构建发送数据（string）
NSString    *msg = [NSString stringWithFormat:@"%@",msgInfo];
NSLog(@"send msg is :%@",msg);
const char *message = [msg UTF8String];
CFDataRef data,recvData = nil;
data = CFDataCreate(NULL, (UInt8 *)message, strlen(message));

// 执行发送操作
CFMessagePortSendRequest(bRemote, msgid, data, 0, 100 , kCFRunLoopDefaultMode, &amp;recvData);
if (nil == recvData) {
    NSLog(@"recvData date is nil.");
    CFRelease(data);
    CFMessagePortInvalidate(bRemote);
    CFRelease(bRemote);
    return nil;
}

// 解析返回数据
const UInt8  * recvedMsg = CFDataGetBytePtr(recvData);
if (nil == recvedMsg) {
    NSLog(@"receive date err.");
    CFRelease(data);
    CFMessagePortInvalidate(bRemote);
    CFRelease(bRemote);
    return nil;
}

NSString    *strMsg = [NSString stringWithCString:(char *)recvedMsg encoding:NSUTF8StringEncoding];
NSLog(@"%@",strMsg);

CFRelease(data);
CFMessagePortInvalidate(bRemote);
CFRelease(bRemote);
CFRelease(recvData);

return strMsg;
</code></pre>

<p>}</p>

<p>```</p>

<p>其中<code>MACH_PORT_REMOTE</code>的定义为：</p>

<p>```objective-c</p>

<h1>define MACH_PORT_REMOTE    &ldquo;com.wangzz.demo&rdquo;</h1>

<p>```</p>

<p>发送消息时要相对简单，首先通过CFMessagePortCreateRemote生成一个Remote的CFMessagePortRef，这里需要注意的是CFMessagePortCreateRemote时传入的字符串唯一标识<code>MACH_PORT_REMOTE</code>必须和消息接收者创建local的CFMessagePortRef时使用的字符串唯一标识是同一个！</p>

<p>通过查看源码发现，CFMessagePortCreateRemote会根据<code>MACH_PORT_REMOTE</code>定义的字符串为唯一标识获取消息接收者通过CFMessagePortCreateLocal使用相同字符串创建的底层mach port端口，从而实现向消息接收者发送信息。</p>

<p>如果消息接收者还没有创建或者通过CFMessagePortCreateLocal创建local端口失败时，想要通过CFMessagePortCreateRemote去创建remote端口肯定是失败的。</p>

<h2>说明</h2>

<ul>
<li>很遗憾的是，在iOS7及以后系统中，CFMessagePort的通信机制不再可用。</li>
</ul>


<p>在使用CFMessagePortCreateLocal/CFMessagePortCreateRemote创建CFMessagePortRef对象时会失败，官方文档中是这么说的：</p>

<p><code>
This method is not available on iOS 7 and later—it will return NULL and log a sandbox violation in syslog. See Concurrency Programming Guide for possible replacement technologies.
</code></p>

<ul>
<li><p>CFMessagePort只能用于本地进程通信。</p></li>
<li><p>CFMessagePort是基于mach port端口的通信方式，不但可以用于进程通信，也可以用于线程间通信，只是线程间通信有了GCD和Cocoa提供的原生方法，已经能很方便的实现了，没必要再使用CFMessagePort。</p></li>
<li><p>进程通信使用场景</p></li>
</ul>


<p>iOS系统多任务机制，使得进程间通信基本都只能用于越狱开发。常用的场景是前端有一个UI程序用于界面展示，后端有一个daemo精灵程序用于任务处理。</p>

<h2>demo工程</h2>

<p>特地做了了个demo工程，以便更好地演示CFMessagePort的使用，可以到<a href="http://download.csdn.net/detail/wzzvictory_tjsd/7446745">CSDN下载</a>。</p>

<p>为了模拟进程间通信场景，我将消息接收进程CFMessagePortReceive做成了能够后台播放音乐的程序，以便其切到后台后能继续存活。</p>

<p>由于CFMessagePort不再支持iOS7及以后系统，本demo实在iOS6系统上测试的。</p>

<p>demo使用方式：</p>

<ul>
<li><p>CFMessagePortReceive启动后，点击Start Listenning创建CFMessagePort接口并开始监听port消息，然后将CFMessagePortReceive切到后台；</p></li>
<li><p>启动CFMessagePortSend程序，在输入框中写入内容，点击发送按钮即可和CFMessagePortReceive通信。</p></li>
<li><p>MessagePort通信过程中会有日志输出，可以使用以下方式查看日志：</p>

<p>  1.真机</p>

<p>  选择：Xcode->Window->Organizer->Devices，然后选中窗口左侧当前设备的Console窗口查看。</p>

<p>  2.模拟器</p>

<p>  选择：模拟器->调试->打开系统日志，或者直接使用快捷键<code>⌘/</code>直接打开系统控制台查看日志。</p></li>
</ul>


<h2>参考文档</h2>

<ul>
<li><p><a href="http://opensource.apple.com/source/CF/CF-855.14/">CF-855.14</a></p></li>
<li><p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">Threading Programming Guide</a></p></li>
<li><p><a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFMessagePortRef/Reference/reference.html#//apple_ref/doc/uid/20001437-CH203-DontLinkElementID_8">CFMessagePort Reference</a></p></li>
</ul>

]]></content>
  </entry>
  
</feed>
