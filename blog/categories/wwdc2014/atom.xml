<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: WWDC2014 | 王中周的技术博客]]></title>
  <link href="http://wangzz.github.io/blog/categories/wwdc2014/atom.xml" rel="self"/>
  <link href="http://wangzz.github.io/"/>
  <updated>2015-05-28T20:57:34+08:00</updated>
  <id>http://wangzz.github.io/</id>
  <author>
    <name><![CDATA[王中周]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[WWDC2014之App Extensions学习笔记]]></title>
    <link href="http://wangzz.github.io/blog/2014/06/23/wwdc2014zhi-app-extensionsxue-xi-bi-ji/"/>
    <updated>2014-06-23T19:55:29+08:00</updated>
    <id>http://wangzz.github.io/blog/2014/06/23/wwdc2014zhi-app-extensionsxue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p><img src="/images/article5/wwdc_banner_promo.jpg" alt="wwdc_banner_promo" /></p>

<h2>一、关于App Extensions</h2>

<p>extension是iOS8新开放的一种对几个固定系统区域的扩展机制，它可以在一定程度上弥补iOS的沙盒机制对应用间通信的限制。</p>

<p>extension的出现，为用户提供了在其它应用中使用我们应用提供的服务的便捷方式，比如用户可以在<code>Today</code>的<code>widgets</code>中查看应用展示的简略信息，而不用再进到我们的应用中，这将是一种全新的用户体验；但是，extension的出现可能会减少用户启动应用的次数，同时还会增大开发者的工作量。</p>

<!-- more -->


<h4>几个关键词</h4>

<ul>
<li>extension point</li>
</ul>


<p>系统中支持extension的区域，extension的类别也是据此区分的，iOS上共有<code>Today</code>、<code>Share</code>、<code>Action</code>、<code>Photo Editing</code>、<code>Storage Provider</code>、<code>Custom keyboard</code>几种，其中<code>Today</code>中的extension又被称为<code>widget</code>。</p>

<p>每种extension point的使用方式和适合干的活都不一样，因此不存在通用的extension。</p>

<ul>
<li>app extension</li>
</ul>


<p>即为本文所说的extension。extension并不是一个独立的app，它有一个包含在app bundle中的独立bundle，extension的bundle后缀名是<code>.appex</code>。其生命周期也和普通app不同，这些后文将会详述。</p>

<p>extension不能单独存在，必须有一个包含它的containing app。</p>

<p>另外，extension需要用户手动激活，不同的extension激活方式也不同，比如：
比如Today中的widget需要在Today中激活和关闭；<code>Custom keyboard</code>需要在设置中进行相关设置；<code>Photo Editing</code>需要在使用照片时在照片管理器中激活或关闭；<code>Storage Provider</code>可以在选择文件时出现；<code>Share</code>和<code>Action</code>可以在任何应用里被激活，但前提是开发者需要设置<code>Activation Rules</code>，以确定extension需要在合适出现。</p>

<ul>
<li>containing app</li>
</ul>


<p>尽管苹果开放了extension，但是在iOS中extension并不能单独存在，要想提交到AppStore，必须将extension包含在一个app中提交，并且app的实现部分不能为空,这个包含extension的app就叫containing app。</p>

<p>extension会随着containing app的安装而安装，同时随着containing app的卸载而卸载。</p>

<ul>
<li>host app</li>
</ul>


<p>能够调起extension的app被称为host app，比如<code>widget</code>的host app就是<code>Today</code>。</p>

<h2>二、extension和containing app、host app</h2>

<h4>2.1 extension和host app</h4>

<p>extension和host app之间可以通过extensionContext属性直接通信，该属性是新增加的UIViewController类别：</p>

<p>```objective-c
@interface UIViewController(NSExtensionAdditions) <NSExtensionRequestHandling></p>

<p>// Returns the extension context. Also acts as a convenience method for a view controller to check if it participating in an extension request.
@property (nonatomic,readonly,retain) NSExtensionContext *extensionContext NS_AVAILABLE_IOS(8_0);</p>

<p>@end
```</p>

<p>实际上extension和host app之间是通过IPC（interprocess communication）实现的，只是苹果把调用接口高度抽象了，我们并不需要关注那么底层的东西。</p>

<h4>2.2 containing app和host app</h4>

<p>他们之间没有任何直接关系，也从来不需要通信。</p>

<h4>2.3 extension和containing app</h4>

<p>这二者之间的关系最复杂，纠纠缠缠扯不清关系。</p>

<ul>
<li>不能直接通信</li>
</ul>


<p>首先，尽管extension的bundle是放在containing app的bundle中，但是他们是两个完全独立的进程，之间不能直接通信。不过extension可以通过openURL的方式启动containing app（当然也能启动其它app），不过必须通过extensionContext借助host app来实现：</p>

<p>```objective-c
//通过openURL的方式启动Containing APP
&ndash; (void)openURLContainingAPP
{</p>

<pre><code>[self.extensionContext openURL:[NSURL URLWithString:@"appextension://123"]
             completionHandler:^(BOOL success) {
                 NSLog(@"open url result:%d",success);
             }];
</code></pre>

<p>}</p>

<p>```</p>

<p>extension中是无法直接使用openURL的。</p>

<ul>
<li>可以共享<code>Shared resources</code></li>
</ul>


<p>extension和containing app可以共同读写一个被称为<code>Shared resources</code>的存储区域，这是通过App Groups实现的，后文将会详述。</p>

<p>三者间的关系可以通过官网给的两张图片形象地说明：</p>

<p><img src="/images/article5/detailed_communication.png" alt="detailed_communication" /></p>

<p><img src="/images/article5/app_extensions_container_restrictions.png" alt="app_extensions_container_restrictions" /></p>

<ul>
<li>containing app能够控制extension的出现和隐藏</li>
</ul>


<p>通过以下代码，containing app可以让extension出现或隐藏（当然extension也可以让自己隐藏）：</p>

<p>```objective-c
//让隐藏的插件重新显示
&ndash; (void)showTodayExtension
{</p>

<pre><code>[[NCWidgetController widgetController] setHasContent:YES forWidgetWithBundleIdentifier:@"com.wangzz.app.extension"];
</code></pre>

<p>}</p>

<p>//隐藏插件
&ndash; (void)hiddeTodayExtension
{</p>

<pre><code>[[NCWidgetController widgetController] setHasContent:NO forWidgetWithBundleIdentifier:@"com.wangzz.app.extension"];
</code></pre>

<p>}
```</p>

<h2>三、App Groups</h2>

<p>这是iOS8新开放的功能，在OS X上早就可用了。它主要用于同一group下的app共享同一份读写空间，以实现数据共享。</p>

<p>extension和containing app共同读写一份数据是很合理的需求，比如系统的股市应用，widget和app中都需要展示几个公司的股票数据，这就可以通过App Groups实现。</p>

<h4>3.1 功能开启</h4>

<p>为了便于后续操作，请先确保你的开发者账号在Xcode上处于登录状态。</p>

<ul>
<li>在app中开启</li>
</ul>


<p>App Groups位于：</p>

<p><code>
TARGETS--&gt;AppExtensionDemo--&gt;Capabilities--&gt;App Groups
</code></p>

<p>找到以后，将App Groups右上角的开关打开，然后选择添加groups，比如我的是group.wangzz，当然这是为了测试随便起得名字，正规点得命名规则应该是：group.com.company.app。</p>

<p>添加成功以后如下图所示：</p>

<p><img src="/images/article5/app_group.png" alt="app_group" /></p>

<ul>
<li>在extension中开启</li>
</ul>


<p>我创建的是widget，target名称为TodayExtension，对应的App Groups位于：</p>

<p><code>
TARGETS--&gt;TodayExtension--&gt;Capabilities--&gt;App Groups
</code>
开启方式和app中一样，需要注意的是必须保证这里地App Groups名称和app中的相同，即为group.wangzz。</p>

<h2>四、extension和containing app数据共享</h2>

<p>App Groups给我们提供了同一group内app可以共同读写的区域，可以通过以下方式实现数据共享：</p>

<h4>4.1 通过NSUserDefaults共享数据</h4>

<ul>
<li>存数据</li>
</ul>


<p>通过以下方式向NSUserDefaults中保存数据：</p>

<p>```objective-c
&ndash; (void)saveTextByNSUserDefaults
{</p>

<pre><code>NSUserDefaults *shared = [[NSUserDefaults alloc] initWithSuiteName:@"group.wangzz"];
[shared setObject:_textField.text forKey:@"wangzz"];
[shared synchronize];
</code></pre>

<p>}</p>

<p>```</p>

<p>需要注意的是：</p>

<p>1.保存数据的时候必须指明group id；</p>

<p>2.而且要注意NSUserDefaults能够处理的数据只能是可plist化的对象，详情见<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/PropertyLists/AboutPropertyLists/AboutPropertyLists.html">Property List Programming Guide</a>。</p>

<p>3.为了防止出现数据同步问题，不要忘记调用<code>[shared synchronize];</code></p>

<ul>
<li>读数据</li>
</ul>


<p>对应的读取数据方式：</p>

<p>```objective-c
&ndash; (NSString *)readDataFromNSUserDefaults
{</p>

<pre><code>NSUserDefaults *shared = [[NSUserDefaults alloc] initWithSuiteName:@"group.wangzz"];
NSString *value = [shared valueForKey:@"wangzz"];

return value;
</code></pre>

<p>}
```</p>

<h4>4.2 通过NSFileManager共享数据</h4>

<p>NSFileManager在iOS7提供了containerURLForSecurityApplicationGroupIdentifier方法，可以用来实现app group共享数据。</p>

<ul>
<li>保存数据</li>
</ul>


<p>```objective-c
&ndash; (BOOL)saveTextByNSFileManager
{</p>

<pre><code>NSError *err = nil;
NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@"group.wangzz"];
containerURL = [containerURL URLByAppendingPathComponent:@"Library/Caches/good"];

NSString *value = _textField.text;
BOOL result = [value writeToURL:containerURL atomically:YES encoding:NSUTF8StringEncoding error:&amp;err];
if (!result) {
    NSLog(@"%@",err);
} else {
    NSLog(@"save value:%@ success.",value);
}

return result;
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>读数据</li>
</ul>


<p>```objective-c</p>

<ul>
<li><p>(NSString <em>)readTextByNSFileManager
{
  NSError </em>err = nil;
  NSURL <em>containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&ldquo;group.wangzz&rdquo;];
  containerURL = [containerURL URLByAppendingPathComponent:@&ldquo;Library/Caches/good&rdquo;];
  NSString </em>value = [NSString stringWithContentsOfURL:containerURL encoding:NSUTF8StringEncoding error:&amp;err];</p>

<p>  return value;
}
```</p></li>
</ul>


<p>在这里我试着保存和读取的是字符串数据，但读写SQlite我相信也是没问题的。</p>

<ul>
<li>数据同步</li>
</ul>


<p>两个应用共同读取同一份数据，就会引发数据同步问题。WWDC2014的视频中建议使用NSFileCoordination实现普通文件的读写同步，而数据库可以使用CoreData,Sqlite也支持同步。</p>

<h2>五、extension和containing app代码共享</h2>

<p>和数据共享类似，extension和containing app很自然地会有一些业务逻辑上可以共用的代码，这时可以通过iOS8中刚开放使用的framework实现。苹果在<a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW1">App Extension Programming Guide</a>中是这样描述的：</p>

<blockquote><p>In iOS 8.0 and later, you can use an embedded framework to share code between your extension and its containing app. For example, if you develop image-processing code that you want both your Photo Editing extension and its containing app to share, you can put the code into a framework and embed it in both targets.</p></blockquote>

<p>即将framework分别嵌入到extension和containing app的target中实现代码共享。但这样岂不是需要分别要将framework分别copy到extension和containing app的main bundle中？</p>

<p>参考extension和containing app数据共享，我试想能不能将framework只保存一份放在App Groups区域？</p>

<h4>5.1 copy framework到App Groups</h4>

<p>在app首次启动的时候将framework放到App Groups区域：</p>

<p>```objective-c</p>

<ul>
<li><p>(BOOL)copyFrameworkFromMainBundleToAppGroup
{
  NSFileManager <em>manager = [NSFileManager defaultManager];
  NSError </em>err = nil;
  NSURL <em>containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&ldquo;group.wangzz&rdquo;];
  NSString </em>sorPath = [NSString stringWithFormat:@&ldquo;%@/Dylib.framework&rdquo;,[[NSBundle mainBundle] bundlePath]];
  NSString *desPath = [NSString stringWithFormat:@&ldquo;%@/Library/Caches/Dylib.framework&rdquo;,containerURL.path];</p>

<p>  BOOL removeResult = [manager removeItemAtPath:desPath error:&amp;err];
  if (!removeResult) {
      NSLog(@&ldquo;%@&rdquo;,err);
  } else {
      NSLog(@&ldquo;remove success.&rdquo;);
  }</p>

<p>  BOOL copyResult = [[NSFileManager defaultManager] copyItemAtPath:sorPath toPath:desPath error:&amp;err];
  if (!copyResult) {
      NSLog(@&ldquo;%@&rdquo;,err);
  } else {
      NSLog(@&ldquo;copy success.&rdquo;);
  }</p>

<p>  return copyResult;
}
```</p></li>
</ul>


<h4>5.2 使用framework：</h4>

<p>```objective-c
&ndash; (BOOL)loadFrameworkInAppGroup
{</p>

<pre><code>NSError *err = nil;
NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@"group.wangzz"];
NSString *desPath = [NSString stringWithFormat:@"%@/Library/Caches/Dylib.framework",containerURL.path];
NSBundle *bundle = [NSBundle bundleWithPath:desPath];
BOOL result = [bundle loadAndReturnError:&amp;err];
if (result) {
    Class root = NSClassFromString(@"Person");
    if (root) {
        Person *person = [[root alloc] init];
        if (person) {
            [person run];
        }
    }
} else {
    NSLog(@"%@",err);
}

return result;
</code></pre>

<p>}</p>

<p>```</p>

<p>经过测试，竟然能够加载成功。</p>

<p>需要说明的是，这里只是说那么用是可以成功加载framework，但还面临不少问题，比如如果用户在启动app之前去使用extension，这时framework还没有copy过去，怎么处理；另外iOS的机制或者苹果的审核是否允许这样使用等。</p>

<p>在一切确定下来之前还是乖乖按文档中的方式使用吧。</p>

<h2>六、生命周期</h2>

<p>extension和普通app的最大区别之一是生命周期。</p>

<ul>
<li>开始</li>
</ul>


<p>在用户通过host app点击extension时，系统就会实例化extension应用，这是生命周期的开始。</p>

<ul>
<li>执行任务</li>
</ul>


<p>在extension启动以后，开始执行它的使命。</p>

<ul>
<li>终止</li>
</ul>


<p>在用户取消任务，或者任务执行结束，或者开启了一个长时后台任务时，系统会将其杀掉。</p>

<p>由此可见，extension就是为了任务而生！</p>

<p>下图来自官方文档，它将生命周期划分的更详细：</p>

<p><img src="/images/article5/app_extensions_lifecycle.png" alt="app_extensions_lifecycle" /></p>

<p>通过打印日志发现，<code>Today</code>中的<code>widget</code>在将<code>Today</code>切换到<code>全部</code>或者<code>未读通知时</code>都会被杀掉。</p>

<h2>七、 调试</h2>

<p>extension和普通app的调试方式差不多，开始调试前先选中extension对应的target，点击run，就会弹出下图所示选择框：</p>

<p><img src="/images/article5/extension_debug.png" alt="extension_debug" /></p>

<p>需要选择一个host app，这里选择<code>Today</code>。</p>

<p>然后即可和普通app一样调试了，不过我在实际使用过程中，发现有各种奇怪的事情，比如NSLog无法在控制台输出，应该是bug吧。</p>

<h2>八、 iOS8应用文件系统</h2>

<p>发现iOS8的文件系统发生了变化，新的文件系统将可执行文件（即原来的.app文件）从沙盒中移到了另外一个地方，这样感觉更合理。</p>

<ul>
<li>测试代码</li>
</ul>


<p>下述代码用于打印App Groups路径、应用的可执行文件路径、对应的Documents路径：</p>

<p>```objective-c</p>

<ul>
<li><p>(void)logAppPath
{
  //app group路径
  NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&ldquo;group.wangzz&rdquo;];
  NSLog(@&ldquo;app group:\n%@&rdquo;,containerURL.path);</p>

<p>  //打印可执行文件路径
  NSLog(@&ldquo;bundle:\n%@&rdquo;,[[NSBundle mainBundle] bundlePath]);</p>

<p>  //打印documents
  NSArray <em>paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
  NSString </em>path = [paths objectAtIndex:0];
  NSLog(@&ldquo;documents:\n%@&rdquo;,path);
}
```</p></li>
<li><p>containing app执行结果</p></li>
</ul>


<p><code>
2014-06-23 19:35:03.944 AppExtensionDemo[7471:365131] app group:
/private/var/mobile/Containers/Shared/AppGroup/89CCBFB1-CA5E-4C7F-80CB-A3EB9E841816
2014-06-23 19:35:03.946 AppExtensionDemo[7471:365131] bundle:
/private/var/mobile/Containers/Bundle/Application/1AC73797-A3BB-4BDE-A647-3D083DA6871A/AppExtensionDemo.app
2014-06-23 19:35:03.948 AppExtensionDemo[7471:365131] documents:
/var/mobile/Containers/Data/Application/E5E6E516-0163-4754-9D10-A5F6C33A6261/Documents
</code></p>

<ul>
<li>extension执行结果</li>
</ul>


<p>```
Jun 23 19:37:49 autonavis-iPad com.foogry.AppExtensionDemo.TodayExtension[7638] <Warning>: app group:</p>

<pre><code>/private/var/mobile/Containers/Shared/AppGroup/89CCBFB1-CA5E-4C7F-80CB-A3EB9E841816
</code></pre>

<p>Jun 23 19:37:49 autonavis-iPad com.foogry.AppExtensionDemo.TodayExtension[7638] <Warning>: bundle:</p>

<pre><code>/private/var/mobile/Containers/Bundle/Application/596717B7-7CB8-4F53-BCD4-380F34ABD30F/AppExtensionDemo.app/PlugIns/com.foogry.AppExtensionDemo.TodayExtension.appex
</code></pre>

<p>Jun 23 19:37:49 autonavis-iPad com.foogry.AppExtensionDemo.TodayExtension[7638] <Warning>: documents:</p>

<pre><code>/var/mobile/Containers/Data/PluginKitPlugin/57581433-3DBD-4930-971F-78D30C150E8A/Documents
</code></pre>

<p>```</p>

<p>由此可见，不管是extension还是containing app，他们的可执行文件和保存数据的目录都是分开存放的，即所有app的可执行文件都放在一个大目录下，保存数据的目录保存在另一个大目录下，同样，AppGroup放在另一个大目录下。</p>

<h2>说明</h2>

<ul>
<li><p>本文用到的demo已经上传到<a href="https://github.com/wangzz/Demo/tree/master/AppExtensionsDemo">github</a>上。</p></li>
<li><p>文中可能有理解有误的地方，还请指出。</p></li>
</ul>


<h2>参考文档</h2>

<ul>
<li><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214-CH20-SW1">App Extension Programming Guide</a></p></li>
<li><p><a href="http://blog.waynehartman.com/">Crash Course In iOS 8 Widgets</a></p></li>
<li><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/NotificationCenter/Reference/NotificationCenter_Framework/index.html#//apple_ref/doc/uid/TP40014443">Notification Center Framework Reference</a></p></li>
<li><p><a href="https://developer.apple.com/library/prerelease/ios/releasenotes/General/RN-iOSSDK-8.0/">iOS 8 Release Notes</a></p></li>
<li><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Miscellaneous/Reference/EntitlementKeyReference/Chapters/EnablingAppSandbox.html#//apple_ref/doc/uid/TP40011195-CH4-SW19">Entitlement Key Reference</a></p></li>
<li><p><a href="http://www.pingwest.com/apples-new-extension-eco-system/">苹果的插件生态系统，开发者的新世界</a></p></li>
<li><p><a href="http://www.macstories.net/stories/ios-8-extensions-apples-plan-for-a-powerful-app-ecosystem/">iOS 8 Extensions: Apple’s Plan for a Powerful App Ecosystem</a></p></li>
<li><p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/PropertyLists/AboutPropertyLists/AboutPropertyLists.html">Property List Programming Guide</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WWDC2014之iOS使用动态库]]></title>
    <link href="http://wangzz.github.io/blog/2014/06/12/wwdc2014zhi-iosshi-yong-dong-tai-ku/"/>
    <updated>2014-06-12T19:27:57+08:00</updated>
    <id>http://wangzz.github.io/blog/2014/06/12/wwdc2014zhi-iosshi-yong-dong-tai-ku</id>
    <content type="html"><![CDATA[<h2>苹果的开放态度</h2>

<p>WWDC2014上发布的<code>Xcode6 beta</code>版有了不少更新，其中令我惊讶的一个是苹果在iOS上开放了动态库，在<code>Xcode6 Beta</code>版的更新文档中是这样描述的：</p>

<blockquote><p>Frameworks for iOS. iOS developers can now create dynamic frameworks. Frameworks are a collection of code and resources to encapsulate functionality that is valuable across multiple projects. Frameworks work perfectly with extensions, sharing logic that can be used by both the main application, and the bundled extensions.</p></blockquote>

<p>详情见官方文档<a href="https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_6_0.html">New Features in Xcode 6 Beta</a>。</p>

<p>framework是Cocoa/Cocoa Touch程序中使用的一种资源打包方式，可以将将代码文件、头文件、资源文件、说明文档等集中在一起，方便开发者使用，作为一名Cocoa/Cocoa Touch程序员每天都要跟各种各样的Framework打交道。Cocoa/Cocoa Touch开发框架本身提供了大量的Framework，比如Foundation.framework/UIKit.framework/AppKit.framework等。需要注意的是，这些framework无一例外都是动态库。</p>

<!-- more -->


<p>但残忍的是，Cocoa Touch上并不允许我们使用自己创建的framework。不过由于framework是一种优秀的资源打包方式，拥有无穷智慧的程序员们便想出了以framework的形式打包静态库的招数，因此我们平时看到的第三方发布的framework无一例外都是静态库，真正的动态库是上不了AppStore的。</p>

<p>WWDC2014给我的一个很大感触是苹果对iOS的开放态度：允许使用动态库、允许第三方键盘、<code>App Extension</code>等等，这些在之前是想都不敢想的事。</p>

<h2>iOS上动态库可以做什么</h2>

<p>和静态库在编译时和app代码链接并打进同一个二进制包中不同，动态库可以在运行时手动加载，这样就可以做很多事情，比如：</p>

<ul>
<li>共享可执行文件</li>
</ul>


<p>在其它大部分平台上，动态库都可以用于不同应用间共享，这就大大节省了内存。从目前来看，iOS仍然不允许进程间共享动态库，即iOS上的动态库只能是私有的，因为我们仍然不能将动态库文件放置在除了自身沙盒以外的其它任何地方。</p>

<p>不过iOS8上开放了<code>App Extension</code>功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的。</p>

<p>2014-6-23修正：</p>

<p>经<a href="http://weibo.com/tangqiaoboy?topnav=1&amp;wvr=5&amp;topsug=1">@唐巧_boy</a>提醒，sandbox会验证动态库的签名，所以如果是动态从服务器更新的动态库，是签名不了的，因此应用插件化、软件版本实时模块升级等功能在iOS上无法实现。</p>

<h2>创建动态库</h2>

<h4>1、创建动态库</h4>

<ul>
<li>创建工程文件</li>
</ul>


<p>在下图所示界面能够找到Cocoa Touch动态库的创建入口：</p>

<p><img src="/images/article4/cocoa_touch_framework.png" alt="framework" /></p>

<p>跟随指引一步步操作即可创建一个新的动态库工程，我的工程名字叫Dylib，Xcode会同时创建一个和工程target同名的.h文件，比如我的就是Dylib.h。</p>

<ul>
<li>向工程中添加文件</li>
</ul>


<p>接下来就可以在工程中随意添加文件了。我在其中新建了一个名为Person的测试类，提供的接口如下：</p>

<p>```objective-c</p>

<p>@interface Person : NSObject</p>

<ul>
<li>(void)run;</li>
</ul>


<p>@end</p>

<p>```</p>

<p>对应的实现部分：</p>

<p>```objective-c</p>

<p>@implementation Person</p>

<ul>
<li><p>(void)run
{
  NSLog(@&ldquo;let&rsquo;s run.&rdquo;);</p>

<p>  UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&ldquo;The Second Alert&rdquo; message:nil delegate:nil cancelButtonTitle:nil otherButtonTitles:@&ldquo;done&rdquo;, nil];
  [alert show];
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<ul>
<li>设置开放的头文件</li>
</ul>


<p>一个库里面可以后很多的代码，但是我们需要设置能够提供给外界使用的接口，可以通过Target&mdash;>Build Phases&mdash;>Headers来设置，如下图所示：</p>

<p><img src="/images/article4/header.png" alt="header" /></p>

<p>我们只需将希望开放的头文件放到Public列表中即可，比如我开放了<code>Dylib.h</code>和<code>Person.h</code>两个头文件，在生成的framework的Header目录下就可以看到这两个头文件，如下图所示：</p>

<p><img src="/images/article4/public_header.png" alt="public_header" /></p>

<p>一切完成，Run以后就能成功生成framework文件了。</p>

<h4>2、通用动态库</h4>

<p>经过第一步我们只是创建了一个动态库文件，但是和静态库类似，该动态库并同时不支持真机和模拟器，可以通过以下步骤创建通用动态库：</p>

<ul>
<li>创建Aggregate Target</li>
</ul>


<p>按下图所示，在动态库工程中添加一个类型为Aggregate的target:</p>

<p><img src="/images/article4/aggregate.png" alt="aggregate" /></p>

<p>按提示一步步操作即可，我给<code>Aggregate</code>的Target的命名是<code>CommonDylib</code>。</p>

<ul>
<li>设置Target Dependencies</li>
</ul>


<p>按以下路径设置<code>CommonDylib</code>对应的<code>Target Dependencies</code>:</p>

<p><code>
TARGETS--&gt;CommonDylib--&gt;Build Phases--&gt;Target Dependencies
</code>
将真正的动态库Dylib Target添加到其中。</p>

<ul>
<li>添加Run Script</li>
</ul>


<p>按以下路径为<code>CommonDylib</code>添加<code>Run Script</code>:</p>

<p><code>
TARGETS--&gt;CommonDylib--&gt;Build Phases--&gt;Run Script
</code></p>

<p>添加的脚本为：</p>

<p>```</p>

<h1>Sets the target folders and the final framework product.</h1>

<p>FMK_NAME=${PROJECT_NAME}</p>

<h1>Install dir will be the final output to the framework.</h1>

<h1>The following line create it in the root folder of the current project.</h1>

<p>INSTALL_DIR=${SRCROOT}/Products/${FMK_NAME}.framework</p>

<h1>Working dir will be deleted after the framework creation.</h1>

<p>WRK_DIR=build
DEVICE_DIR=${WRK_DIR}/Release-iphoneos/${FMK_NAME}.framework
SIMULATOR_DIR=${WRK_DIR}/Release-iphonesimulator/${FMK_NAME}.framework</p>

<h1>-configuration ${CONFIGURATION}</h1>

<h1>Clean and Building both architectures.</h1>

<p>xcodebuild -configuration &ldquo;Release&rdquo; -target &ldquo;${FMK_NAME}&rdquo; -sdk iphoneos clean build
xcodebuild -configuration &ldquo;Release&rdquo; -target &ldquo;${FMK_NAME}&rdquo; -sdk iphonesimulator clean build</p>

<h1>Cleaning the oldest.</h1>

<p>if [ -d &ldquo;${INSTALL_DIR}&rdquo; ]
then
rm -rf &ldquo;${INSTALL_DIR}&rdquo;
fi</p>

<p>mkdir -p &ldquo;${INSTALL_DIR}&rdquo;</p>

<p>cp -R &ldquo;${DEVICE_DIR}/&rdquo; &ldquo;${INSTALL_DIR}/&rdquo;</p>

<h1>Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.</h1>

<p>lipo -create &ldquo;${DEVICE_DIR}/${FMK_NAME}&rdquo; &ldquo;${SIMULATOR_DIR}/${FMK_NAME}&rdquo; -output &ldquo;${INSTALL_DIR}/${FMK_NAME}&rdquo;</p>

<p>rm -r &ldquo;${WRK_DIR}&rdquo;</p>

<p>```</p>

<p>添加以后的效果如图所示：</p>

<p><img src="/images/article4/commonlib_setting.png" alt="commonlib_setting" /></p>

<p>该脚本是我根据一篇文章中介绍的脚本改写的，感谢<a href="http://blog.sina.com.cn/s/blog_407fb5bc01013v6s.html">原文作者</a>。</p>

<p>脚本的主要功能是：</p>

<p>1.分别编译生成真机和模拟器使用的framework；
2.使用lipo命令将其合并成一个通用framework；
3.最后将生成的通用framework放置在工程根目录下新建的Products目录下。</p>

<p>如果一切顺利，对<code>CommonDylib</code> target执行run操作以后就能生成一个如图所示的通用framework文件了：</p>

<p><img src="/images/article4/products.png" alt="products" /></p>

<h2>使用动态库</h2>

<h4>添加动态库到工程文件</h4>

<p>经过以上步骤的努力，生成了最终需要的framework文件，为了演示动态库的使用，新建了一个名为<code>FrameworkDemo</code>的工程。通过以下方式将刚生成的framework添加到工程中：</p>

<p><code>
Targets--&gt;Build Phases--&gt;Link Binary With Libraries
</code></p>

<p>同时设置将framework作为资源文件拷贝到Bundle中：</p>

<p><code>
Targets--&gt;Build Phases--&gt;Copy Bundle Resources
</code></p>

<p>如图所示：</p>

<p><img src="/images/article4/framework_demo_setting.png" alt="framework_demo_setting" /></p>

<p>仅仅这样做是不够的，还需要为动态库添加链接依赖。</p>

<h4>自动链接动态库</h4>

<p>添加完动态库后，如果希望动态库在软件启动时自动链接，可以通过以下方式设置动态库依赖路径：</p>

<p><code>
Targets--&gt;Build Setting--&gt;Linking--&gt;Runpath Search Paths
</code></p>

<p>由于向工程中添加动态库时，将动态库设置了Copy Bundle Resources，因此就可以将<code>Runpath Search Paths</code>路径依赖设置为main bundle，即沙盒中的FrameworkDemo.app目录，向<code>Runpath Search Paths</code>中添加下述内容：</p>

<p><code>
@executable_path/
</code></p>

<p>如图所示：</p>

<p><img src="/images/article4/run_search_path.png" alt="run_search_path" /></p>

<p>其中的<code>@executable_path/</code>表示可执行文件所在路径，即沙盒中的.app目录，注意不要漏掉最后的<code>/</code>。</p>

<p>如果你将动态库放到了沙盒中的其他目录，只需要添加对应路径的依赖就可以了。</p>

<h4>需要的时候链接动态库</h4>

<p>动态库的另一个重要特性就是<code>即插即用</code>性，我们可以选择在需要的时候再加载动态库。</p>

<ul>
<li>更改设置</li>
</ul>


<p>如果不希望在软件一启动就加载动态库，需要将</p>

<p><code>
Targets--&gt;Build Phases--&gt;Link Binary With Libraries
</code></p>

<p>中<code>Dylib.framework</code>对应的Status由默认的<code>Required</code>改成<code>Optional</code>；或者更干脆的，将<code>Dylib.framework</code>从<code>Link Binary With Libraries</code>列表中删除即可。</p>

<ul>
<li>使用dlopen加载动态库</li>
</ul>


<p>以<code>Dylib.framework</code>为例，动态库中真正的可执行代码为<code>Dylib.framework/Dylib</code>文件，因此使用dlopen时如果仅仅指定加载动态库的路径为<code>Dylib.framework</code>是没法成功加载的。</p>

<p>示例代码如下：</p>

<p>```objective-c</p>

<ul>
<li><p>(IBAction)onDlopenLoadAtPathAction1:(id)sender
{
  NSString *documentsPath = [NSString stringWithFormat:@&ldquo;%@/Documents/Dylib.framework/Dylib&rdquo;,NSHomeDirectory()];
  [self dlopenLoadDylibWithPath:documentsPath];
}</p></li>
<li><p>(void)dlopenLoadDylibWithPath:(NSString <em>)path
{
  libHandle = NULL;
  libHandle = dlopen([path cStringUsingEncoding:NSUTF8StringEncoding], RTLD_NOW);
  if (libHandle == NULL) {
      char </em>error = dlerror();
      NSLog(@&ldquo;dlopen error: %s&rdquo;, error);
  } else {
      NSLog(@&ldquo;dlopen load framework success.&rdquo;);
  }
}
```</p></li>
</ul>


<p>以dlopen方式使用动态库不知道是否能通过苹果审核。</p>

<ul>
<li>使用NSBundle加载动态库</li>
</ul>


<p>也可以使用NSBundle来加载动态库，实现代码如下：</p>

<p>```objective-c</p>

<ul>
<li><p>(IBAction)onBundleLoadAtPathAction1:(id)sender
{
  NSString *documentsPath = [NSString stringWithFormat:@&ldquo;%@/Documents/Dylib.framework&rdquo;,NSHomeDirectory()];
  [self bundleLoadDylibWithPath:documentsPath];
}</p></li>
<li><p>(void)bundleLoadDylibWithPath:(NSString <em>)path
{
  _libPath = path;
  NSError </em>err = nil;
  NSBundle *bundle = [NSBundle bundleWithPath:path];
  if ([bundle loadAndReturnError:&amp;err]) {
      NSLog(@&ldquo;bundle load framework success.&rdquo;);
  } else {
      NSLog(@&ldquo;bundle load framework err:%@&rdquo;,err);
  }
}</p></li>
</ul>


<p>```</p>

<h4>使用动态库中代码</h4>

<p>通过上述任一一种方式加载的动态库后，就可以使用动态库中的代码文件了，以<code>Dylib.framework</code>中的<code>Person</code>类的使用为例：</p>

<p>```objective-c
&ndash; (IBAction)onTriggerButtonAction:(id)sender
{</p>

<pre><code>Class rootClass = NSClassFromString(@"Person");
if (rootClass) {
    id object = [[rootClass alloc] init];
    [(Person *)object run];
}
</code></pre>

<p>}</p>

<p>```</p>

<p>注意，如果直接通过下属方式初始化<code>Person</code>类是不成功的：</p>

<p>```objective-c
&ndash; (IBAction)onTriggerButtonAction:(id)sender
{</p>

<pre><code>Person *object = [[Person alloc] init];
if (object) {
   [object run];
}
</code></pre>

<p>}</p>

<p>```</p>

<h2>监测动态库的加载和移除</h2>

<p>我们可以通过下述方式，为动态库的加载和移除添加监听回调：</p>

<p>```objective-c</p>

<ul>
<li>(void)load
{
  <em>dyld_register_func_for_add_image(&amp;image_added);
  </em>dyld_register_func_for_remove_image(&amp;image_removed);
}</li>
</ul>


<p>```</p>

<p>github上有一个完整的<a href="https://github.com/ddeville/ImageLogger">示例代码</a>，</p>

<p>从这里看出，原来就算空白工程软件启动的时候也会加载多达一百二十多个动态库，如果这些都是静态库，那该有多可怕！！</p>

<h2>Demo</h2>

<p>本文使用的例子已经上传到<a href="https://github.com/wangzz/Demo/tree/master/FrameworkDemo">github</a>上，需要的朋友请自取。</p>

<p>另外，本文对某些东西可能有理解错误的地方，还请指出。</p>

<h2>参考文档：</h2>

<ul>
<li><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html#//apple_ref/doc/uid/10000183-SW1">Framework Programming Guide</a></p></li>
<li><p><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/dyld.1.html">OS X Man Pages</a></p></li>
<li><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_6_0.html">New Features in Xcode 6 Beta</a></p></li>
<li><p><a href="https://github.com/ddeville/ImageLogger">ImageLogger</a></p></li>
<li><p><a href="http://realmacsoftware.com/blog/dynamic-linking?utm_campaign=iOS_Dev_Weekly_Issue_140&amp;utm_medium=email&amp;utm_source=iOS%2BDev%2BWeekly">Dynamic Linking</a></p></li>
<li><p><a href="http://en.wikipedia.org/wiki/Dynamic_loading#Mac_OS_X">Dynamic loading</a></p></li>
<li><p><a href="http://support.revealapp.com/kb/getting-started/integrating-reveal-with-your-ios-app#dynamic-library-integration">Integrating Reveal with your iOS app</a></p></li>
<li><p><a href="http://blog.sina.com.cn/s/blog_407fb5bc01013v6s.html">IOS Framework制作全攻略</a></p></li>
<li><p><a href="http://www.tanhao.me/pieces/1361.html">Build Settings中的变量@rpath,@loader_path,@executable_path</a></p></li>
<li><p><a href="http://www.cocoachina.com/newbie/basic/2012/0516/4255.html">深入浅出Cocoa之Framework</a></p></li>
<li><p><a href="http://blog.sina.com.cn/s/blog_a843a8850101rv9k.html">linux中静态库和动态库的区别和汇总</a></p></li>
</ul>

]]></content>
  </entry>
  
</feed>
